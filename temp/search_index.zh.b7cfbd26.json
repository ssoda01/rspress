[{"id":42,"title":"内置组件","content":"#\n\n\nBadge#\n\nBadge 组件用于展示状态的标记。使用方法如下：\n\n\n\n效果如下：\n\n其中包含的 props 类型如下：\n\n\n\n\nHelmet#\n\n一般用于在文档中设置自定义 head 内容(底层使用 react-helmet-async)。使用方法如下：\n\n\n\n\nHomeFeature#\n\nHome 页面 Feature 组件，查看本站的效果\n\n\n\n\nHomeHero#\n\nHome 页面 Hero 组件\n\n\n\n\nLastUpdated#\n\nLastUpdated 组件用来显示文章的最后更新时间。使用方法如下：\n\n\n\nTIP\n\n如果没有在默认主题中配置 lastUpdated: true 的话需要安装和注册 @rspress/plugin-last-updated 插件。\n\n\nNoSSR#\n\n用于在服务端渲染时不渲染某些组件。使用方法如下：\n\n\n\n\nOverview#\n\n预览组件，查看本站的效果\n\n\n\n\nPackageManagerTabs#\n\nPackageManagerTabs 组件用于在文档中展示不同包管理器的命令。使用方法如下：\n\n\n\n效果如下：\n\n其中包含的 props 类型如下：\n\n\n\n当 command 设置为字符串时，会默认展示 npm、yarn、pnpm、bun 四个 tab，并且组件内部为自动在 command\n前面添加对应的包管理器命令。如果你需要展示额外的 tab，可以通过 additionalTabs 来实现。\n\nTIP\n\n在 install 命令中，对 yarn 和 bun 做了特殊处理，如果你的命令是install some-packages，在 yarn 和 bun 的\ntab 中会自动将 install 替换为 add。\n\n\nPrevNextPage#\n\nPrevNextPage 组件用来渲染上一页和下一页的链接。使用方法如下：\n\n\n\n其中包含的 props 类型如下：\n\n\n\n\nSourceCode#\n\nSourceCode 组件用来跳转到源代码。使用方法如下：\n\n\n\n效果如下：\n\n其中包含的 props 类型如下：\n\n\n\n\nSteps#\n\nSteps 组件用于将编号列表转换为步骤的可视化表示形式。使用方法如下：\n\n\n\n效果如下:\n\n\nTab/Tabs#\n\n你可以在文档中直接使用 Tab/Tabs 组件来实现 tab 切换的效果。比如\n\n\n\n提醒\n\n为了让你更方便地使用这些组件，框架内部对于 rspress/theme 这个包做了 alias 处理，所以你可以直接使用 @theme 来引入这些组件。\n\n其中 Tabs 组件的 props 类型如下:\n\n\n\ndefaultValue 用于设置默认选中的 tab 项，这个值会和 Tab 组件的 value 字段做比较，如果相等则选中该 tab。\n\ngroupId 用于设置 tab 项的分组，当你需要多个 Tabs 组件进行联动的时候，可以通过 groupId 来实现。groupId 相同的 Tabs\n组件会进行联动。\n\ntabPosition 用于设置 tab 列表的排列位置，目前支持 left 和 center 两个值，分为表示靠左和居中，默认为 left。\n\nTab 组件的 props 类型如下:\n\n\n\n其中的 value 字段用于标识当前 tab，如果不传则默认使用 label。\n\n\nTable of Contents#\n\n渲染当前页面的 TOC\n\n","routePath":"/zh/api/client-api/api-components","lang":"zh","toc":[{"text":"Badge","id":"badge","depth":2,"charIndex":3},{"text":"Helmet","id":"helmet","depth":2,"charIndex":69},{"text":"HomeFeature","id":"homefeature","depth":2,"charIndex":137},{"text":"HomeHero","id":"homehero","depth":2,"charIndex":182},{"text":"LastUpdated","id":"lastupdated","depth":2,"charIndex":213},{"text":"NoSSR","id":"nossr","depth":2,"charIndex":347},{"text":"Overview","id":"overview","depth":2,"charIndex":384},{"text":"PackageManagerTabs","id":"packagemanagertabs","depth":2,"charIndex":412},{"text":"PrevNextPage","id":"prevnextpage","depth":2,"charIndex":746},{"text":"SourceCode","id":"sourcecode","depth":2,"charIndex":824},{"text":"Steps","id":"steps","depth":2,"charIndex":899},{"text":"Tab/Tabs","id":"tabtabs","depth":2,"charIndex":955},{"text":"Table of Contents","id":"table-of-contents","depth":2,"charIndex":1414}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"Runtime API","content":"#\n\nRspress 暴露一些运行时 API，方便你做一些自定义的逻辑。\n\n\nusePageData#\n\n获取当前页面的数据，返回值为一个对象，包含了当前页面的所有数据。\n\n\n\n\nuseLang#\n\n获取当前语言，返回值为一个字符串，即当前语言。\n\n\n\n\nuseVersion#\n\n在多版本文档的场景下，获取当前文档版本，返回值为一个字符串，即当前版本。\n\n\n\n\nuseDark#\n\n当前主题是否为暗黑模式，返回值为一个布尔值。\n\n\n\n\nuseI18n#\n\n框架提供了 useI18n 这个 hook 来获取国际化文本，使用方式如下：\n\n\n\n为了获得更好的类型提示，你可以在 tsconfig.json 中配置 paths:\n\n\n\n然后在组件中这样使用:\n\n\n\n这样你就可以获得 i18n.json 中定义的所有文本 key 的类型提示了。\n\n\n路由 Hook#\n\n框架内部使用并重导出了 react-router-dom 的所有 API，你可以这样来使用:\n\n","routePath":"/zh/api/client-api/api-runtime","lang":"zh","toc":[{"text":"usePageData","id":"usepagedata","depth":2,"charIndex":38},{"text":"useLang","id":"uselang","depth":2,"charIndex":89},{"text":"useVersion","id":"useversion","depth":2,"charIndex":127},{"text":"useDark","id":"usedark","depth":2,"charIndex":181},{"text":"useI18n","id":"usei18n","depth":2,"charIndex":218},{"text":"路由 Hook","id":"路由-hook","depth":2,"charIndex":372}],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"命令","content":"#\n\n通过本章节，你可以了解到 Rspress 内置的命令有哪些，以及如何使用这些命令。\n\n\nrspress dev#\n\nrspress dev 命令用于启动一个本地开发服务器，提供一个文档进行预览和调试的开发环境。\n\n\n\n\nrspress build#\n\nrspress build 命令用于构建出针对生产环境的文档产物。\n\n\n\n\nrspress preview#\n\nrspress preview 命令用于在本地预览 rspress build 命令构建出的产物。\n\n\n\n\nrspress update#\n\nrspress update 命令用于将 rspress 相关的依赖更新到最新版本。\n\n","routePath":"/zh/api/commands","lang":"zh","toc":[{"text":"rspress dev","id":"rspress-dev","depth":2,"charIndex":46},{"text":"rspress build","id":"rspress-build","depth":2,"charIndex":112},{"text":"rspress preview","id":"rspress-preview","depth":2,"charIndex":166},{"text":"rspress update","id":"rspress-update","depth":2,"charIndex":238}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"基础配置","content":"#\n\n\nroot#\n\n * Type: string\n * Default: docs\n\n指定文档根目录。比如：\n\n\n\n该配置同时支持相对路径和绝对路径，相对路径相对于当前工作目录。\n\n当然，除了通过配置文件来指定文档根目录，你也可以通过命令行参数来指定，比如：\n\n\n\n\nbase#\n\n * Type: string\n * Default: /\n\n部署基路径。比如，如果你计划将你的站点部署到 https://foo.github.io/bar/，那么你应该将 base 设置为 \"/bar/\"：\n\n\n\n\ntitle#\n\n * Type: string\n * Default: \"Island\"\n\n站点标题。这个参数将被用作 HTML 页面的标题。例如：\n\n\n\n\ndescription#\n\n * Type: string\n * Default: \"\"\n\n站点描述。这将用作 HTML 页面的描述。例如：\n\n\n\n\nicon#\n\n * Type: string\n * Default: \"\"\n\n站点图标。这个路径将用作 HTML 页面的图标路径。例如：\n\n\n\n框架会在 public 目录中找到你的图标，当然你也可以设置成一个 CDN 地址。\n\n\nlogo#\n\n * Type: string | { dark: string; light: string }\n * Default: \"\"\n\n站点 logo。这个路径将用作导航栏左上角的 logo 路径。例如：\n\n\n\n框架会在 public 目录中找到你的图标，当然你也可以设置成一个 CDN 地址。\n\n当然你可以针对浅色/暗黑模式设置不同的 logo：\n\n\n\n\nlogoText#\n\n * Type: string\n * Default: \"\"\n\n站点 logo 文字。这个文字将用作导航栏左上角的 logo 文字。例如：\n\n\n\n\noutDir#\n\n * Type: string\n * Default: doc_build\n\n自定义构建站点的输出目录。比如:\n\n\n\n\nlocales#\n\n * Type: Locale[]\n\n\n\n站点的多语言配置。比如：\n\n\n\n\nmediumZoom#\n\n * Type: boolean | { selector?: string }\n * Default: true\n\n是否开启图片放大功能。默认开启，你可以通过设置 mediumZoom 为 false 来关闭。\n\n> 底层使用的是 medium-zoom 库来实现的。\n\n使用示例：\n\n\n\n\nsearch#\n\n * Type: { searchHooks: string }\n\n你可以通过 searchHooks 参数来增加搜索运行时钩子逻辑，比如：\n\n\n\n关于具体的钩子逻辑，你可以阅读 自定义搜索功能。\n\n\nglobalUIComponents#\n\n * Type: (string | object)[]\n * Default: []\n\n你可以通过 globalUIComponents 参数来增加全局 UI 组件，比如：\n\n\n\nglobalUIComponents 的每一项可以是一个字符串，代表组件的文件路径；也可以是一个数组，第一项为组件的文件路径，第二项为组件的 props\n对象，比如：\n\n\n\n当你注册了全局组件之后，框架会自动将这些 React 组件在主题中进行渲染，而不用你手动引入。\n\n通过全局组件，你可以完成诸多自定义的功能，比如:\n\n\n\n这样，在主题页面中会渲染组件的内容，比如添加回到顶部按钮。\n\n同时，你也可以通过全局组件来注册全局副作用。比如：\n\n\n\n这样，在主题页面中会执行组件的副作用。比如以下的一些需要副作用的场景:\n\n * 针对某些页面路由进行重定向操作。\n\n * 对页面的 img 标签进行事件监听，实现图片放大功能。\n\n * 路由变化时，上报不同页面的 PV 数据。\n\n * ......\n\n\nmultiVersion#\n\n * Type: { default: string; versions: string[] }\n\n你可以通过 multiVersion 参数来增加多版本文档支持，比如：\n\n\n\n其中，default 为默认版本，versions 为所有版本列表。\n\n\nroute#\n\n * Type: Object\n\n自定义路由配置。\n\n\nroute.include#\n\n * Type: string[]\n * Default: []\n\n在路由中添加一些额外的文件。默认情况下，只有文档根目录中的文件才会包含在路由中。如果你想在路由中添加一些额外的文件，你可以使用这个选项。例如：\n\n\n\n> 注意：数组中的字符串支持 glob 模式。\n\n\nroute.exclude#\n\n * Type: string[]\n * Default: []\n\n从路由中排除一些文件。例如：\n\n\n\n> 注意：数组中的字符串支持 glob 模式。\n\n\nroute.extensions#\n\n * Type: string[]\n * Default: []\n\n将包含在路由中的文件的扩展名。默认情况下，Rspress 会在路由中包含所有 `'js'、'jsx'、'ts'、'tsx'、'md'、'mdx'\n文件。如果你想自定义扩展名，你可以使用这个选项。例如：\n\n\n\n\nroute.cleanUrls#\n\n * Type: boolean\n * Default: false\n\n开启后可以生成无 .html 后缀的链接，URL 可以更加简洁。\n\n\n\n\nssg#\n\n * Type: boolean\n * Default: true\n\n是否开启静态站点生成。默认开启，你可以通过设置 ssg 为 false 来关闭。\n\n","routePath":"/zh/api/config/config-basic","lang":"zh","toc":[{"text":"root","id":"root","depth":2,"charIndex":3},{"text":"base","id":"base","depth":2,"charIndex":135},{"text":"title","id":"title","depth":2,"charIndex":252},{"text":"description","id":"description","depth":2,"charIndex":331},{"text":"icon","id":"icon","depth":2,"charIndex":406},{"text":"logo","id":"logo-1","depth":2,"charIndex":-1},{"text":"logoText","id":"logotext","depth":2,"charIndex":706},{"text":"outDir","id":"outdir","depth":2,"charIndex":791},{"text":"locales","id":"locales","depth":2,"charIndex":860},{"text":"mediumZoom","id":"mediumzoom","depth":2,"charIndex":908},{"text":"search","id":"search","depth":2,"charIndex":1068},{"text":"globalUIComponents","id":"globaluicomponents","depth":2,"charIndex":1178},{"text":"multiVersion","id":"multiversion","depth":2,"charIndex":1641},{"text":"route","id":"route","depth":2,"charIndex":1782},{"text":"route.include","id":"routeinclude","depth":3,"charIndex":1818},{"text":"route.exclude","id":"routeexclude","depth":3,"charIndex":1969},{"text":"route.extensions","id":"routeextensions","depth":3,"charIndex":2063},{"text":"route.cleanUrls","id":"routecleanurls","depth":3,"charIndex":2221},{"text":"ssg","id":"ssg","depth":2,"charIndex":2312}],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"构建配置","content":"#\n\n\nbuilderConfig#\n\n * Type: Object\n\n用于自定义 Rsbuild 的配置项，完整配置项请查看 Rsbuild - 配置。\n\n比如，将产物目录修改为 doc_dist：\n\n\n\n\nbuilderPlugins#\n\n * Type: RsbuildPlugin[]\n\n用于加入 Rsbuild 的插件，比如：\n\n\n\n\n默认配置#\n\n如果你需要查看默认的 builderConfig，可以在执行 rspress dev 或 rspress build 命令时，添加 DEBUG=rsbuild\n参数：\n\n\n\n在执行后，doc_build 目录下会生成 rsbuild.config.js 文件，里面包含了完整的 builderConfig。\n\n> 请查看 Rsbuild - 调试模式 来了解更多调试 Rsbuild 的方法。\n\n\nmarkdown#\n\n * Type: Object\n\n配置 MDX 相关的编译能力。\n\n\nmarkdown.remarkPlugins#\n\n * Type: Array\n * Default: []\n\n配置 remark 插件。比如：\n\n\n\n\nmarkdown.rehypePlugins#\n\n * Type: Array\n\n配置 rehype 插件。比如：\n\n\n\n\nmarkdown.checkDeadLinks#\n\n * Type: boolean\n * Default: false\n\n是否检查死链。比如：\n\n\n\n开启这个配置后，框架会基于约定式路由表对文档中的链接进行检查，若出现无法访问的链接，构建会抛出错误并退出。\n\n\nmarkdown.mdxRs#\n\n * Type: boolean | { include: (filepath: string) => boolean }\n\n * Default: true\n\n是否使用 MDX 的 Rust 版本编译器，默认开启。比如：\n\n\n\n你也可以提供函数来决定哪些文件使用 MDX 的 Rust 版本编译器。比如：\n\n\n\n注意\n\nmdxRs 能力底层基于 Rspress 自研的 @rspress/mdx-rs 库来实现，性能比 JS 版本的 MDX 编译器提升 10 倍以上，但不支持\nJS 的插件。\n\n\nmarkdown.showLineNumbers#\n\n * Type: boolean\n\n是否显示代码块的行号。默认为 false。\n\n\nmarkdown.defaultWrapCode#\n\n * Type: boolean\n\n是否默认启用长代码换行展示。默认为 false。\n\n\nmarkdown.globalComponents#\n\n * Type: string[]\n\n注册全局组件，无需通过导入声明，就可以在每个 MDX 文件中使用。比如：\n\n\n\n这样你就可以在 MDX 文件中使用 Alert 组件了：\n\n\n\n警告\n\n请在配置 globalComponents 时设置 markdown.mdxRs 为 false 以开启 JS 版本的编译器，否则会导致全局组件不生效。\n\n\nmarkdown.highlightLanguages#\n\n * Type: (string | [string, string])[]\n\n注册需要高亮的语言。默认支持的语言包括js、jsx、ts、tsx、json、css、scss、less、xml、diff、yaml、md、mdx、bash，你可\n以在这些语言的基础上进行扩展。比如：\n\n\n\n每项语言的配置支持 string 和 [string, string]\n两种格式，在数组的格式下，前者为语言的别名，后者为语言的全名，你可以前往文件列表查看所有支持的语言全名。","routePath":"/zh/api/config/config-build","lang":"zh","toc":[{"text":"builderConfig","id":"builderconfig","depth":2,"charIndex":3},{"text":"builderPlugins","id":"builderplugins","depth":2,"charIndex":105},{"text":"默认配置","id":"默认配置","depth":3,"charIndex":173},{"text":"markdown","id":"markdown","depth":2,"charIndex":379},{"text":"markdown.remarkPlugins","id":"markdownremarkplugins","depth":3,"charIndex":425},{"text":"markdown.rehypePlugins","id":"markdownrehypeplugins","depth":3,"charIndex":502},{"text":"markdown.checkDeadLinks","id":"markdowncheckdeadlinks","depth":3,"charIndex":564},{"text":"markdown.mdxRs","id":"markdownmdxrs","depth":3,"charIndex":696},{"text":"markdown.showLineNumbers","id":"markdownshowlinenumbers","depth":3,"charIndex":963},{"text":"markdown.defaultWrapCode","id":"markdowndefaultwrapcode","depth":3,"charIndex":1032},{"text":"markdown.globalComponents","id":"markdownglobalcomponents","depth":3,"charIndex":1104},{"text":"markdown.highlightLanguages","id":"markdownhighlightlanguages","depth":3,"charIndex":1306}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"Front Matter 配置","content":"#\n\n\ntitle#\n\n * Type: string\n\n页面的标题。默认情况下，页面的 h1 标题将用作 HTML 文档的标题。但是如果你想使用不同的标题，你可以使用 Front Matter\n来指定页面的标题。例如：\n\n\n\n\ndescription#\n\n * Type: string\n\n页面的自定义描述。例如：\n\n\n\n\npageType#\n\n * Type: 'home' | 'doc' | 'custom' | 'blank' | '404'\n * Default: 'doc'\n\n页面的类型。默认情况下，页面类型为doc。但是如果你想使用不同的页面类型，你可以使用pageType这个 Front Matter 字段来指定页面类型。例如：\n\n\n\n各个pageType配置的含义如下：\n\n\nhero#\n\n * Type: Object\n\nhome 页面的 hero 配置。它有以下类型：\n\n\n\n例如，你可以使用以下 Front Matter 来指定页面的 hero config：\n\n\n\n或者你也可以用 HTML 来指定页面的 hero config：\n\n\n\n\nfeatures#\n\n * Type: Array\n * Default: []\n\nhome 页面的功能配置。它有以下类型：\n\n\n\n例如，你可以使用以下内容来指定 home 页面的 features 配置：\n\n\n\n\nsidebar#\n\n是否展示左侧的目录栏。默认情况下，doc 页面会展示左侧的目录栏。但是如果你想隐藏左侧的目录栏，你可以使用以下 Front Matter 来配置：\n\n\n\n\noutline#\n\n是否展示右侧的大纲栏。默认情况下，doc 页面会展示右侧的大纲栏。你可以通过下面的配置来隐藏大纲栏：\n\n\n\n\nfooter#\n\n是否展示文档底部的组件(如上一页/下一页)。默认情况下，doc 页面会展示底部的 footer。你可以通过下面的配置来隐藏 footer：\n\n\n\n\nnavbar#\n\n是否展示顶部导航栏。默认情况下，所有页面都会展示顶部导航栏。但是如果你想隐藏顶部导航栏，你可以使用以下 Front Matter 来配置：\n\n","routePath":"/zh/api/config/config-frontmatter","lang":"zh","toc":[{"text":"title","id":"title","depth":2,"charIndex":3},{"text":"description","id":"description","depth":2,"charIndex":114},{"text":"pageType","id":"pagetype","depth":2,"charIndex":162},{"text":"hero","id":"hero","depth":2,"charIndex":349},{"text":"features","id":"features","depth":2,"charIndex":485},{"text":"sidebar","id":"sidebar","depth":2,"charIndex":593},{"text":"outline","id":"outline","depth":2,"charIndex":681},{"text":"footer","id":"footer","depth":2,"charIndex":746},{"text":"navbar","id":"navbar","depth":2,"charIndex":829}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"主题配置","content":"#\n\n主题配置位于 doc 配置中的 themeConfig 下。例如：\n\n\n\n\nnav#\n\n * Type: Array\n * Default: []\n\n网站的导航栏。 nav 配置是 NavItem 的数组，具有以下类型：\n\n\n\nactiveMatch 用于匹配当前路由，当路由匹配 activeMatch 规则时，nav 项会高亮显示。默认情况下，activeMatch 是 nav 项的\nlink。\n\n比如:\n\n\n\n当然 nav 数组中也可以配置多级菜单，类型如下:\n\n\n\n例如下面的配置:\n\n\n\n\nsidebar#\n\n * Type: Object\n\n网站的侧边栏。配置为一个对象，类型如下：\n\n\n\n比如:\n\n\n\n\nfooter#\n\n * Type: Object\n * Default: {}\n\n主页的页脚。\n\nfooter 配置是 Footer 的一个对象，它具有以下类型：\n\n\n\n比如：\n\n\n\n\noutlineTitle#\n\n * Type: string\n * Default: 'ON THIS PAGE'\n\n在右侧边栏中配置大纲的标题。\n\n比如:\n\n\n\n\nlastUpdated#\n\n * Type: boolean\n * Default: false\n\n是否显示最后更新时间，默认情况下不显示。\n\n比如:\n\n\n\n\nlastUpdatedText#\n\n * Type: string\n * Default: Last Updated\n\n最后更新时间的文本。\n\n比如:\n\n\n\n\nprevPageText#\n\n * Type: string\n * Default: Previous Page\n\n上一页的文本。比如:\n\n\n\n\nsearchPlaceholderText#\n\n * Type: string\n * Default: Search Docs\n\n搜索框的占位符文本。比如:\n\n\n\n\nsocialLinks#\n\n * Type: Array\n * Default: []\n\n你可以通过如下的配置添加相关链接，比如 github 链接、twitter 链接等。 相关链接支持三种模式：链接模式link 文本模式text\n图片模式img，相关例子如下：\n\n\n\n * 当link模式时，点击 icon 即可跳转链接。\n * 当text模式时，鼠标移到 icon 上会显示弹框，弹框内容是输入的文本。\n * 当img模式时，鼠标移到 icon 上会显示弹框，弹框内容是指定的图片，需要注意的是，图片需要放在public目录下。\n\n相关链接支持以下几种图片，通过 icon 属性来选择：\n\n\n\n如果需要自定义 icon，可以通过传入一个带有svg属性的对象，svg 的值为自定义图标内容即可，比如：\n\n\n\n\nnextPageText#\n\n * Type: string\n * Default: Next Page\n\n下一页的文本。比如:\n\n\n\n\nlocales#\n\n * Type: Array\n * Default: undefined\n\n国际化配置。此配置为一个数组，数组中的每一项都是一个 LocaleConfig 对象，它具有以下类型：\n\n\n\nLocaleConfig 中包含许多与主题配置中相同的配置项，但它的优先级会更高。\n\n\ndarkMode#\n\n * Type: boolean\n * Default: true\n\n是否出现暗黑模式/白天模式切换按钮。比如：\n\n\n\n同时，你也可以通过在 HTML 中注入如下的全局变量来指定默认的主题模式：\n\n\n\n\nhideNavbar#\n\n * Type: \"always\" | \"auto\" | \"never\"\n * Default: never\n\n控制隐藏导航栏行为。默认情况下，导航栏总是显示。你可以设置为 auto 来实现页面向下滚动时导航栏自动隐藏，或者设置为 always 来总是隐藏导航栏。\n\n。比如：\n\n\n\n\nenableContentAnimation#\n\n * Type: boolean\n * Default: false\n\n在页面切换的时候是否显示转场动画，例如：\n\n> 转场动画暂时不能配置。\n\n\n\n\nsearch#\n\n * Type: boolean\n * Default: true\n\n是否显示搜索框。比如：\n\n\n\n\nsourceCodeText#\n\n * Type: string\n * Default: Source\n\n源代码按钮的文本。比如：\n\n\n\n\nenableScrollToTop#\n\n * Type: boolean\n * Default: false\n\n启用文档上的滚动到顶部按钮. 比如:\n\n","routePath":"/zh/api/config/config-theme","lang":"zh","toc":[{"text":"nav","id":"nav","depth":2,"charIndex":40},{"text":"sidebar","id":"sidebar","depth":2,"charIndex":253},{"text":"footer","id":"footer","depth":2,"charIndex":312},{"text":"outlineTitle","id":"outlinetitle","depth":2,"charIndex":405},{"text":"lastUpdated","id":"lastupdated","depth":2,"charIndex":488},{"text":"lastUpdatedText","id":"lastupdatedtext","depth":2,"charIndex":568},{"text":"prevPageText","id":"prevpagetext","depth":2,"charIndex":648},{"text":"searchPlaceholderText","id":"searchplaceholdertext","depth":2,"charIndex":721},{"text":"socialLinks","id":"sociallinks","depth":2,"charIndex":804},{"text":"nextPageText","id":"nextpagetext","depth":2,"charIndex":1161},{"text":"locales","id":"locales","depth":2,"charIndex":1230},{"text":"darkMode","id":"darkmode","depth":2,"charIndex":1377},{"text":"hideNavbar","id":"hidenavbar","depth":2,"charIndex":1490},{"text":"enableContentAnimation","id":"enablecontentanimation","depth":2,"charIndex":1646},{"text":"search","id":"search","depth":2,"charIndex":1747},{"text":"sourceCodeText","id":"sourcecodetext","depth":2,"charIndex":1807},{"text":"enableScrollToTop","id":"enablescrolltotop","depth":2,"charIndex":1877}],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"","content":"","routePath":"/zh/api/","lang":"zh","toc":[],"domain":"","frontmatter":{"overview":true},"version":""},{"id":50,"title":"自定义搜索功能","content":"#\n\n在某些场景下，我们需要对搜索功能进行定制，比如：\n\n * 对搜索过程中的关键词进行处理，比如去除敏感词\n * 对默认的全文搜索结果进行过滤\n * 对搜索关键字进行打点上报\n * 自定义搜索数据源，比如从数据库中搜索\n * 对自定义搜索数据源进行渲染\n * ......\n\n面对这些灵活的自定义需求，我们提供了相应的接口，对默认主题的搜索组件进行扩展，让你可以很容易地定制搜索功能。\n\n\nsearchHooks 概念和配置#\n\n在 Rspress 配置中，我们提供了 search.searchHooks 配置项，用于配置搜索组件的钩子函数，如下：\n\n\n\nsearch.searchHooks 配置项的值为一个文件路径，这个文件会导出对应的钩子逻辑，如\nonSearch，从而让你可以定制搜索运行时的能力。我们可以称这个文件为 searchHooks 模块。\n\n\nsearchHooks 中的钩子函数#\n\n下面我们来介绍 searchHooks 中的钩子函数，即 beforeSearch、onSearch、afterRender、render。\n\n提示\n\n在 searchHooks 模块中，你只需要导出你需要的钩子函数，而不是必须导出全部的钩子函数。\n\n\nbeforeSearch#\n\nbeforeSearch 钩子函数会在搜索开始前执行，你可以用来对搜索关键字进行处理，比如去除敏感词，或者对搜索关键字进行打点上报。\n\n> 该钩子支持异步操作。\n\n使用示例如下：\n\n\n\n\nonSearch#\n\nonSearch 钩子函数会在默认的全文搜索逻辑完成之后执行，你可以在这个钩子函数中对搜索结果进行过滤或者上报，也可以在这个钩子函数中增加自定义的搜索数据源。\n\n> 该钩子支持异步操作。\n\n使用示例如下：\n\n\n\n需要注意的是，onSearch 钩子函数的返回值为一个数组，数组中的每一项为一个搜索源的结果，每一项的结构如下：\n\n\n\n其中 result 为搜索结果，你可以自定义内部的结构。如果 renderType 为\nRenderType.Default，则会使用默认的渲染方式进行渲染，如果为 RenderType.Custom，则会使用 render\n钩子函数中的渲染方式进行渲染。\n\n\nafterSearch#\n\nafterSearch 钩子函数会在搜索结果渲染完成之后执行，你可以在这个钩子拿到最终的搜索关键词和搜索结果。\n\n> 该钩子支持异步操作。\n\n使用示例如下：\n\n\n\n\nrender#\n\nrender 函数会对你在 onSearch 钩子中自定义的搜索源数据进行渲染，因此一般需要和 onSearch 一起使用。使用方式如下：\n\n\n\n效果如下：\n\n","routePath":"/zh/guide/advanced/custom-search","lang":"zh","toc":[{"text":"searchHooks 概念和配置","id":"searchhooks-概念和配置","depth":2,"charIndex":195},{"text":"searchHooks 中的钩子函数","id":"searchhooks-中的钩子函数","depth":2,"charIndex":383},{"text":"beforeSearch","id":"beforesearch","depth":3,"charIndex":531},{"text":"onSearch","id":"onsearch","depth":3,"charIndex":640},{"text":"afterSearch","id":"aftersearch","depth":3,"charIndex":948},{"text":"render","id":"render","depth":3,"charIndex":1045}],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"自定义主题","content":"#\n\n本文所要介绍的是如何开发一套自定义主题。\n\n\n基于默认主题的扩展#\n\n大部分情况下，你并不想从零开始开发一个主题，而是想基于默认主题进行扩展，这时候可以参考下面的方式进行主题开发。\n\nTIP\n\n如果你想从头开发一套自定义主题，可以前往【重新开发自定义主题】。\n\n\n1. 基本结构#\n\n默认情况下，你需要在项目根目录下创建一个 theme 目录，然后在 theme 目录下创建一个 index.ts 或者 index.tsx\n文件，该文件用于导出主题配置。\n\n\n\n你可以使用如下的方式来书写 theme/index.tsx 文件:\n\n\n\n一方面你需要通过 export default 导出一个主题配置对象，另一方面你需要通过 export * from 'rspress/theme'\n导出所有具名导出的内容，这样才能保证你的主题配置能够正常工作。\n\n\n2. 使用插槽#\n\n值得注意的是，Layout 组件设计了一系列的 props 支持插槽元素，你可以通过这些 props 来扩展默认主题的布局，比如将上面的 Layout\n组件改成如下的形式:\n\n\n\n\n3. 自定义组件#\n\n要扩展默认主题的组件，除了插槽方式以外，你还可以自定义 Home 页面组件及 404 页面组件， 以及其他 Rspress 内置的组件。比如:\n\n\n\n当然，在开发过程可能需要使用页面的数据，你可以通过 Runtime API 来获取。\n\n\n4. 自定义图标#\n\n如果想要单独修改默认主题组件里用到的图标，只需要将同名图标放在 theme/assets 目录下即可。\n\n\n\n你可以在 这里 查看默认主题中用到的所有图标。\n\n\n重新开发自定义主题#\n\n如果你要从头开始开发一个自定义主题，你需要了解一下主题的组成。\n\n\n1. 基本结构#\n\n默认情况下，你需要在项目根目录下创建一个 theme 目录，然后在 theme 目录下创建一个 index.ts 或者 index.tsx\n文件，该文件用于导出主题配置。\n\n\n\n在 theme/index.tsx 文件中，你需要导出一个 Layout 组件，这个组件就是你的主题的入口组件:\n\n\n\n这个 Layout 组件会被用来渲染整个文档站点的布局，你可以在这个组件中引入你的自定义组件，比如:\n\n\n\n那么问题来了，主题组件是如何获取页面数据和正文 MDX 组件内容的呢？接下来我们来看看相关的 API。\n\n\n2. 运行时 API#\n\nusePageData#\n\n获取站点所有数据的信息，比如:\n\n\n\nuseLang#\n\n获取当前语言信息，比如:\n\n\n\nContent#\n\n正文 MDX 组件内容，如:\n\n\n\n路由 Hook#\n\n框架内部用 react-router-dom 来实现路由，所以你可以直接使用 react-router-dom 的 Hook，比如:\n\n\n\n\n3. 搜索功能复用#\n\n默认主题内置了搜索功能，我们可以将搜索组件拆分为两部分：\n\n 1. 搜索框，即唤起搜索的入口。\n 2. 点击搜索框后弹出的搜索面板。\n\n完整复用#\n\n如果你想完整复用搜索功能，你可以直接引入 Search 组件，比如:\n\n\n\n复用搜索面板#\n\n如果你仅仅想复用搜索面板，想要自定义搜索框部分，那么你需要在你的主题组件中引入 SearchPanel 组件，比如:\n\n\n\n其中，你需要自己维护 focused 状态和 setFocused 方法，并且作为 props 传给 SearchPanel\n组件，用于控制搜索面板的显示和隐藏。\n\n复用默认全文搜索逻辑#\n\n如果你想复用默认的全文搜索逻辑，你可以使用 useFullTextSearch Hook，比如:\n\n\n\n其中，initialized 表示搜索是否初始化完成，search 方法用于搜索关键字，返回一个 Promise，Promise 的结果为默认全文搜索的结果。\n\n需要注意的是，useFullTextSearch Hook 会在初始化时自动加载搜索索引，所以你需要先判断 initialized\n状态，确保初始化完成之后，然后再调用 search 方法。\n\nsearch 方法的类型定义如下:\n\n\n\nlimit 表示搜索结果的最大数量，默认为 7，也就是默认最多返回七篇文章的结果。","routePath":"/zh/guide/advanced/custom-theme","lang":"zh","toc":[{"text":"基于默认主题的扩展","id":"基于默认主题的扩展","depth":2,"charIndex":25},{"text":"1. 基本结构","id":"1-基本结构","depth":3,"charIndex":134},{"text":"2. 使用插槽","id":"2-使用插槽","depth":3,"charIndex":379},{"text":"3. 自定义组件","id":"3-自定义组件","depth":3,"charIndex":480},{"text":"4. 自定义图标","id":"4-自定义图标","depth":3,"charIndex":611},{"text":"重新开发自定义主题","id":"重新开发自定义主题","depth":2,"charIndex":703},{"text":"1. 基本结构","id":"1-基本结构-1","depth":3,"charIndex":749},{"text":"2. 运行时 API","id":"2-运行时-api","depth":3,"charIndex":1016},{"text":"usePageData","id":"usepagedata","depth":4,"charIndex":1029},{"text":"useLang","id":"uselang","depth":4,"charIndex":1062},{"text":"Content","id":"content","depth":4,"charIndex":1088},{"text":"路由 Hook","id":"路由-hook","depth":4,"charIndex":1116},{"text":"3. 搜索功能复用","id":"3-搜索功能复用","depth":3,"charIndex":1197},{"text":"完整复用","id":"完整复用","depth":4,"charIndex":1277},{"text":"复用搜索面板","id":"复用搜索面板","depth":4,"charIndex":1322},{"text":"复用默认全文搜索逻辑","id":"复用默认全文搜索逻辑","depth":4,"charIndex":1476}],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"构建能力扩展","content":"#\n\n\nRsbuild#\n\nRspress 底层基于 Rsbuild 来进行文档构建。\n\nRsbuild 提供了丰富的构建配置，你可以使用 builderConfig 来自定义这些配置项。比如，将产物目录修改为 doc_dist：\n\n\n\nTIP\n\n你可以通过 Rsbuild - 配置 的文档来了解更多的配置项。\n\n注意，Rspress 仅支持 Rspack 打包工具，因此一些与 webpack 相关的配置项将无法生效，比如 tools.webpack。当然，你可以通过\ntools.rspack 来修改 Rspack 的配置。\n\n\nMDX 编译插件#\n\n在框架中 MDX 的编译基于 unified 完成，你可以通过 markdown 配置来添加相关的编译插件。比如\n\n\n\n注意\n\n仅 JS 版本的 MDX 编译器支持编译插件。","routePath":"/zh/guide/advanced/extend-build","lang":"zh","toc":[{"text":"Rsbuild","id":"rsbuild","depth":2,"charIndex":3},{"text":"MDX 编译插件","id":"mdx-编译插件","depth":2,"charIndex":267}],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"自动化导航栏/侧边栏","content":"#\n\n在 Rspress 中，除了在配置文件中通过 themeConfig 声明 nav 和 sidebar， 你也可以通过声明 _meta.json\n描述文件来自动化生成导航栏和侧边栏，我们更加推荐后者，因为可以使配置文件更加简洁和清晰。\n\n提示\n\n当配置文件 rspress.config.ts 中没有 nav 和 sidebar 配置的情况下，自动化导航栏/侧边栏才会生效。\n\n\n基础概念#\n\n首先，_meta.json 可以分为两类：导航栏级别和侧边栏级别。两者的区别在于，导航级别的 _meta.json 位于文档根目录中，而侧边栏级别的\n_meta.json 位于文档根目录的子目录中。比如:\n\n\n\n如果你的文档使用了国际化，那么导航栏级别的 _meta.json 会放置在对应语言目录下，比如：\n\n\n\n\n导航栏级别配置#\n\n在导航栏级别的情况中，你可以在 _meta.json 中填入一个数组，其类型跟默认主题的 nav 配置完全一致，详情可以参考 nav 配置。比如:\n\n\n\n\n侧边栏级别配置#\n\n在侧边栏级别的情况中，你可以在 _meta.json 中填入一个数组，数组每一项的类型如下:\n\n\n\n\nstring#\n\n当类型为 string 时，表示该项是一个文件，文件名为该字符串，比如:\n\n\n\n其中文件名可以带后缀，也可以不带后缀，比如 introduction 会被解析为 introduction.mdx。\n\n\nobject#\n\n当类型为对象形式时，你可以描述为一个文件、目录或者自定义链接。\n\n在描述文件的情况下，类型如下:\n\n\n\n其中，name 表示文件名，同时支持带/不带后缀，label 表示该文件在侧边栏中的显示名称，为可选值，如果未填则会自动取文档中的 h1 标题。比如:\n\n\n\n在描述目录的情况下，类型如下:\n\n\n\n其中，name 表示目录名，label 表示该目录在侧边栏中的显示名称，collapsible 表示该目录是否可以折叠，collapsed\n表示该目录是否默认折叠，比如:\n\n\n\n在描述分割线的情况下，类型如下：\n\n\n\ndashed 为 true 时表示该分割线是虚线，否则是实线。\n\n提示\n\n如果想要点击侧边栏目录显示某篇文档，你可以在当前目录同级创建一个同名的 md(x) 文件，比如：\n\n\n\n这样，当你点击 Advanced 目录时，会显示 advanced.mdx 文件的内容。\n\n在描述分组标题的情况下，类型如下:\n\n\n\n其中，label 表示该分组标题在侧边栏中的显示名称，比如:\n\n\n\n这样，你可以在侧边栏中添加分组标题，方便对文档和目录进行分组。一般情况下，你可以配合 divider 使用，来更好的区分不同的分组。比如:\n\n\n\n在描述自定义链接的情况下，类型如下:\n\n\n\n其中，label 表示该链接在侧边栏中的显示名称，link 表示该链接的跳转地址，比如:\n\n\n\nlink 支持外部链接，比如:\n\n\n\n\n完整示例#\n\n下面是一个完整的示例，用到了上述的三种类型:\n\n\n\n\n无配置用法#\n\n某些目录下你可以不配置\n_meta.json，让框架自动帮你生成侧边栏。这需要保证目录下仅包含文档，而不包含子目录，并且你对文档的顺序没有要求。比如现在有如下的文档结构:\n\n\n\n在 guides 目录中你可以配置 _meta.json 内容如下:\n\n\n\n而在 basic 目录中，你可以不配置\n_meta.json，框架会自动帮你生成侧边栏，默认按照文件名的字母顺序排序。如果你想要自定义顺序，可以在文件名前加上数字前缀，比如:\n\n\n\n\n标题前添加 svg 图标#\n\n此外，你还可以通过 tag 配置在标题前添加图标，比如:\n\n\n\ntag 的值为 svg 标签字符串或者图片 URL，你可以将其配置到导航栏或者侧边栏中。","routePath":"/zh/guide/basic/auto-nav-sidebar","lang":"zh","toc":[{"text":"基础概念","id":"基础概念","depth":2,"charIndex":192},{"text":"导航栏级别配置","id":"导航栏级别配置","depth":2,"charIndex":358},{"text":"侧边栏级别配置","id":"侧边栏级别配置","depth":2,"charIndex":446},{"text":"string","id":"string","depth":3,"charIndex":507},{"text":"object","id":"object","depth":3,"charIndex":617},{"text":"完整示例","id":"完整示例","depth":3,"charIndex":1238},{"text":"无配置用法","id":"无配置用法","depth":3,"charIndex":1272},{"text":"标题前添加 svg 图标","id":"标题前添加-svg-图标","depth":3,"charIndex":1499}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"约定式路由","content":"#\n\n\n什么是约定式路由#\n\nRspress 使用的是文件系统路由，页面的文件路径会简单的映射为路由路径，这样会让整个项目的路由非常直观。\n\n例如，如果在 docs 目录中有一个名为 foo.md 的文件，则该文件的路由路径将是 /foo。\n\n\n映射规则#\n\nRspress 会自动扫描根目录和所有子目录，并将文件路径映射到路由路径。例如，如果你有以下的文件结构：\n\n\n\n那么 bar.md 的路由路径会是 /foo/bar，foo.md 的路由路径会是 /foo。\n\n具体映射规则如下：\n\n文件路径            路由路径\nindex.md        /\n/foo.md         /foo\n/foo/bar.md     /foo/bar\n/zoo/index.md   /zoo/\n\n\n组件路由#\n\n在约定式路由中，除了 .md(x) 文件，还可以使用 .tsx 文件作为路由组件，在 .tsx 中默认导出一个组件，该组件会被自动注册到路由中。例如：\n\n\n\n当然，如果你想要定制布局，可以添加一个导出，声明布局类型，例如：\n\n\n\n各个 pageType 的含义详情请参考 API 文档。\n\n\n自定义行为#\n\n如果要自定义路由行为，可以使用配置文件中的 route 字段。例如：\n\n\n\n\n最佳实践#\n\n我们推荐你将文档文件放在 docs 目录下，这样可以让你的项目更加清晰。而对于非文档内容，比如自定义组件、工具函数等，可以放到 docs\n目录之外进行维护。比如：\n\n","routePath":"/zh/guide/basic/conventional-route","lang":"zh","toc":[{"text":"什么是约定式路由","id":"什么是约定式路由","depth":2,"charIndex":3},{"text":"映射规则","id":"映射规则","depth":2,"charIndex":122},{"text":"组件路由","id":"组件路由","depth":2,"charIndex":354},{"text":"自定义行为","id":"自定义行为","depth":2,"charIndex":507},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":554}],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"自定义页面","content":"#\n\nRspress 提供了多种方式能让你自定义页面的内容，包括：\n\n * 添加自定义全局组件；\n * 添加自定义全局样式；\n * 自定义页面布局结构。\n\n\n自定义全局组件#\n\n某些场景下，你可能需要在页面中添加一些自定义的全局组件，框架提供了一个配置项 globalUIComponents 来实现这个功能。\n\n\n使用方法#\n\n在 rspress.config.ts 中添加以下配置：\n\n\n\nglobalUIComponents 的每一项可以是一个字符串，代表组件的文件路径；也可以是一个数组，第一项为组件的文件路径，第二项为组件的 props\n对象，比如：\n\n\n\n\n自定义样式#\n\n某些场景下，你可能需要在主题 UI 的基础上添加一些全局样式，框架提供了一个配置项 globalStyles 来实现这个功能。\n\n\n使用方法#\n\n在 rspress.config.ts 中添加以下配置：\n\n\n\n然后可以添加以下代码：\n\n\n\n这样框架会自动搜集所有的全局样式并合并到最终的样式文件中。\n\n下面列举一些常用的全局样式：\n\n\n\n> 如果想了解更多内部的全局样式，可以查看 vars.css\n\n\nTailwind CSS#\n\n要在 Rspress 中使用 Tailwind CSS，你可以按照以下步骤操作：\n\n 1. 安装 Tailwind CSS：\n\n 2. 创建一个包含 tailwindcss 插件的 postcss.config.js 文件：\n\n\n\n 3. 创建一个 tailwind.config.js 文件，并确保 content 包含了所有使用 Tailwind CSS 的文件：\n\n\n\n 4. 在你的 CSS 样式文件中添加 Tailwind 指令，参考 自定义样式：\n\n\n\n> 请参考官方 Tailwind CSS 文档 了解最新用法。\n\n\n自定义布局结构#\n\nRspress 提供了 pageType 配置来让你自定义页面的布局结构。\n\n\n使用 pageType#\n\nRspress 的约定式路由支持了两种路由，一种是文档路由，即用 md(x) 文件编写的页面，另一种是组件路由，即 .jsx/.tsx 文件编写的页面。\n\n对于前者，你可以在 frontmatter 中添加 pageType 字段来指定页面的布局结构，比如：\n\n\n\n对于后者，你可以添加如下的导出来指定 pageType：\n\n\n\npageType 可以配置为如下的值：\n\n\n使用细粒度开关#\n\n除了 pageType 页面布局级别的配置之外，Rspress 还提供了更细粒度的开关，你可以在 frontmatter 配置其它的字段，这些字段及其含义如下：\n\n * navbar：是否展示顶部导航栏，当你想要隐藏顶部导航栏时，可以配置为 false；\n * sidebar：是否展示侧边栏，当你想要隐藏侧边栏时，可以配置为 false；\n * outline：是否展示大纲栏，当你想要隐藏大纲栏时，可以配置为 false；\n * footer：是否展示页脚，当你想要隐藏页脚时，可以配置为 false；\n * globalComponents: 是否展示全局组件，当你想要隐藏全局组件时，可以配置为 false。\n\n示例：\n\n\n\n\n使用 URL 参数开关#\n\n除此之外，你还可以使用 URL 参数在运行时控制页面的布局结构，比如：\n\n\n\n通过 URL 参数，你可以在不修改源码的情况下，快速地调整页面的布局结构，这些参数具体包括：\n\n * navbar：是否展示导航栏，当你想要隐藏顶部导航栏时，可以配置为 0；\n * sidebar：是否展示侧边栏，当你想要隐藏侧边栏时，可以配置为 0；\n * outline：是否展示大纲栏，当你想要隐藏大纲栏时，可以配置为 0；\n * footer：是否展示页脚，当你想要隐藏页脚时，可以配置为 0；\n * globalUIComponents：是否展示全局组件，当你想要隐藏全局组件时，可以配置为 0。","routePath":"/zh/guide/basic/custom-page","lang":"zh","toc":[{"text":"自定义全局组件","id":"自定义全局组件","depth":2,"charIndex":78},{"text":"使用方法","id":"使用方法","depth":3,"charIndex":157},{"text":"自定义样式","id":"自定义样式","depth":2,"charIndex":284},{"text":"使用方法","id":"使用方法-1","depth":3,"charIndex":358},{"text":"Tailwind CSS","id":"tailwind-css","depth":3,"charIndex":494},{"text":"自定义布局结构","id":"自定义布局结构","depth":2,"charIndex":776},{"text":"使用 pageType","id":"使用-pagetype","depth":3,"charIndex":826},{"text":"使用细粒度开关","id":"使用细粒度开关","depth":3,"charIndex":1027},{"text":"使用 URL 参数开关","id":"使用-url-参数开关","depth":3,"charIndex":1355}],"domain":"","frontmatter":{},"version":""},{"id":56,"title":"项目部署","content":"#\n\n这一节我们将来讲解项目的部署环节，我们假定你已经完成了项目的开发，现在需要将项目部署到线上。你需要考虑如下的方面：\n\n * 项目生产环境构建和预览；\n * 静态资源前缀配置；\n * 项目基路径配置；\n * 选择部署平台进行部署。\n\n\n项目生产环境构建和预览#\n\n在部署之前，我们需要先对项目进行生产环境的构建，并在本地进行预览，以确保项目能够正常运行。在 Rspress 项目中，我们可以通过下面的 scripts\n命令来进行构建和预览：\n\n\n\n提示\n\n对于 preview 命令，你可以通过 --port 参数来指定预览的端口号，例如 rspress preview --port 8080。\n\n值得关注的是，最后的产物会被输出到项目根目录的 doc_build 目录下，这个目录下的内容就是我们需要部署的内容。\n\n\n静态资源前缀配置#\n\n我们可以把部署产物分为两部分：HTML 文件和静态资源。HTML 文件指的是产物目录中的 HTML 文件，这些文件是我们最终部署到服务器上的文件。\n\n而所谓的静态资源，指的是产物目录中的 static 目录，里面包含了项目所需要的\nJavaScript、CSS、图片等静态资源。在部署的时候，如果你想要将这些静态资源放到 CDN 上，以保证更好的访问性能，而不是像 HTML\n一样直接放到服务器上，那么你就需要配置静态资源的前缀，这样才能够让项目正确的引用到这些静态资源，你可以通过\nbuilderConfig.output.assetPrefix 来完成：\n\n\n\n这样，在 HTML 中引用静态资源的时候，就会自动加上前缀，例如：\n\n\n\n\n项目基路径配置#\n\n在部署的时候，我们可能需要将项目部署到一个子路径下，比如，如果你计划将你的站点部署到 https://foo.github.io/bar/，那么你应该将\nbase 参数设置为 \"/bar/\"：\n\n\n\n\n选择部署平台进行部署#\n\n在完成了上面的配置之后，我们就可以将产物部署到服务器上了。你有很多种选择，比如 GitHub Pages、Netlify、Vercel 等等。这里我们以\nGitHub Pages 和 Netlify 为例，来讲解如何部署。\n\n\n通过 GitHub Actions 部署#\n\n如果你的项目是托管在 GitHub 上的，那么你可以通过 GitHub Pages 来进行部署。GitHub Pages 是 GitHub\n提供的一个静态网站托管服务，它可以让你直接将你的项目部署到 GitHub 上，而不需要你自己搭建服务器。\n\n1. 创建 Workflow 文件#\n\n首先，你需要你需要在项目根目录下创建一个名为 .github/workflows/deploy.yml 的文件，内容如下：\n\n\n\n2. 配置 GitHub Actions#\n\n在仓库 Settings 界面中的 Pages 栏目中，你可以选择 GitHub Actions 作为部署源。\n\n3. 推送代码到 main 分支#\n\n当你将代码推送到 main 分支的时候，GitHub Actions 就会自动执行部署流程，你可以在 Actions\n栏目中查看部署的进度。当部署完成之后，你就可以通过 https://.github.io// 来访问你的站点了。\n\n\n通过 Netlify 部署#\n\nNetlify 是一个 Web 应用部署平台，它可以让你直接将你的项目部署到 Netlify 上，而不需要你自己搭建服务器。\n\n完成基础配置#\n\n在 Netlify 上部署项目非常简单，你只需要引入你的 Github 仓库，然后配置一些基础信息就可以部署了，主要配置下面两个字段即可：\n\n * Build command：构建命令，这里我们填写项目中的 build 命令即可，如 npm run build。\n * Publish directory：产物目录，这里我们填写项目中的产物目录 doc_build。\n\n然后点击 Deploy site 按钮，就可以完成部署了。\n\n配置自定义域名#\n\n如果你想要将你的站点绑定到自己的域名上，那么你可以在 Netlify 的 Domain management 栏目中进行配置，具体的配置方法可以参考\nNetlify 官方文档。\n\n\n通过 Kinsta 部署#\n\n你可以在 Kinsta 上部署你的 Rspress 网站。\n\n 1. 登录或创建账户，来查看你的 MyKinsta 面板。\n\n 2. 通过 Git 提供商授权 Kinsta。\n\n 3. 从左侧边栏选择 Static Sites，然后点击 Add sites。\n\n 4. 选择需要部署的仓库和分支。\n\n 5. 在构建设置中，Kinsta 会尝试自动填写 Build command、Node version 以及 Publish\n    directory。如果没有自动填写，请填写以下内容：\n    \n    * 构建命令: npm run build\n    * Node 版本: 18.16.0\n    * 发布目录: doc_build\n\n 6. 点击 Create site。\n\n\n部署到 Zeabur#\n\nZeabur 是一个让开发者能够快速部署自己的项目的平台，你能够在此快速地部署你的 Rspress 站点而无需任何配置。\n\n如何部署#\n\n首先，你需要 创建一个 Zeabur 账号。然后，跟随引导来创建一个项目，并安装 GitHub 应用以授权 Zeabur 访问你的 Rspress 仓库。\n\n点击 Deploy New Service 并导入你的仓库，部署将会自动开始进行，并且 Zeabur 会自动识别你的站点是使用 Rspress 构建的。\n\n部署将在几分钟内完成，你也可以同时在该页面为你的站点绑定 Zeabur 提供的免费子域名或者自己购买的自定义域名。","routePath":"/zh/guide/basic/deploy","lang":"zh","toc":[{"text":"项目生产环境构建和预览","id":"项目生产环境构建和预览","depth":2,"charIndex":119},{"text":"静态资源前缀配置","id":"静态资源前缀配置","depth":2,"charIndex":362},{"text":"项目基路径配置","id":"项目基路径配置","depth":2,"charIndex":694},{"text":"选择部署平台进行部署","id":"选择部署平台进行部署","depth":2,"charIndex":805},{"text":"通过 GitHub Actions 部署","id":"通过-github-actions-部署","depth":3,"charIndex":932},{"text":"1. 创建 Workflow 文件","id":"1-创建-workflow-文件","depth":4,"charIndex":1079},{"text":"2. 配置 GitHub Actions","id":"2-配置-github-actions","depth":4,"charIndex":1164},{"text":"3. 推送代码到 main 分支","id":"3-推送代码到-main-分支","depth":4,"charIndex":1244},{"text":"通过 Netlify 部署","id":"通过-netlify-部署","depth":3,"charIndex":1381},{"text":"完成基础配置","id":"完成基础配置","depth":4,"charIndex":1461},{"text":"配置自定义域名","id":"配置自定义域名","depth":4,"charIndex":1686},{"text":"通过 Kinsta 部署","id":"通过-kinsta-部署","depth":3,"charIndex":1787},{"text":"部署到 Zeabur","id":"部署到-zeabur","depth":3,"charIndex":2147},{"text":"如何部署","id":"如何部署","depth":4,"charIndex":2222}],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"静态站点生成（SSG）","content":"#\n\n\n功能介绍#\n\n在生产环境的构建中，Rspress 会自动帮你生成静态站点，即生成各个页面的 HTML 内容，在构建完成之后，HTML 会出现在默认的产物目录中，比如：\n\n\n\n你可以将这个产物目录的内容部署到任何静态站点托管服务上，比如 Github Pages、Netlify、Vercel 等。\n\n\nSSG 的优势#\n\n静态站点生成的本质是在构建阶段进行组件的预渲染，将组件渲染成 HTML 字符串，然后写入到 HTML 文件中，这样做有诸多的好处，比如：\n\n * 首屏渲染速度更快，因为不需要等待 JS 加载完成之后再进行渲染。\n * 更利于 SEO，因为搜索引擎爬虫可以直接抓取到完整的 HTML 内容。\n\n而考虑到静态站点生成的成本，Rspress 只有在生产环境构建时才会进行预渲染，而在开发环境下，仍然是采用传统的 SPA 渲染模式，没有进行预渲染。\n\n\n添加自定义站点内容#\n\n通过 builderConfig.html.tags，你可以自定义站点 HTML 内容，比如添加统计代码、添加脚本和样式等。\n\n\n\n关于 builderConfig.html.tags 更详细的配置，请参考文档。\n\n\n预览产物#\n\n在生产环境构建完成之后，你可以通过 rspress preview\n命令来预览产物，这个命令会启动一个本地的静态站点服务，你可以在浏览器中访问这个服务来预览产物。\n\n\n\n\n关闭 SSG#\n\n如果你不想使用静态站点生成，可以通过 ssg 配置来关闭它。\n\n\n\n注意\n\n请谨慎关闭 SSG，因为这会丧失上文中提到的静态站点生成的诸多优势。","routePath":"/zh/guide/basic/ssg","lang":"zh","toc":[{"text":"功能介绍","id":"功能介绍","depth":2,"charIndex":3},{"text":"SSG 的优势","id":"ssg-的优势","depth":2,"charIndex":154},{"text":"添加自定义站点内容","id":"添加自定义站点内容","depth":2,"charIndex":387},{"text":"预览产物","id":"预览产物","depth":2,"charIndex":508},{"text":"关闭 SSG","id":"关闭-ssg","depth":2,"charIndex":601}],"domain":"","frontmatter":{},"version":""},{"id":58,"title":"静态资源处理","content":"#\n\n\n介绍#\n\n在 Rspress 中，你将有可能使用到如下的静态资源：\n\n * 站点左上角 logo 图片\n * 站点 favicon 图标\n * 主页 logo 图片\n * .md(x) 文件中使用的图片、视频等静态资源\n * 其它静态资源\n\n接下来我们将逐个介绍如何使用这些静态资源。\n\n提示\n\n下文提到的 文档根目录 指的是 rspress.config.ts 中的 root 字段指定的目录：\n\n\n\n\n左上角 logo#\n\n在 Rspress 中，你可以通过 logo 字段来指定左上角的 logo 图片。例如：\n\n\n\nlogo 字段支持字符串和对象两种配置方式。\n\n当 logo 是一个字符串时，有如下的配置情况：\n\n * 配置为外链，如上面的例子。\n * 配置为绝对路径，如 /rspress-logo.png，这样 Rspress 在框架内部会自动在你的文档根目录的 public 目录中找到\n   rspress-logo.png 图片并进行展示。\n * 配置为相对路径，如 ./docs/public/rspress-logo.png，这样 Rspress 基于项目根目录寻找到\n   rspress-logo.png 图片并进行展示。\n\n如果你的网站需要适配暗黑模式，那么也可以使用 logo 的对象配置，如：\n\n\n\n其中，light 代表浅色模式下的 logo 地址，而 dark 代表暗黑模式下的 logo 地址，各自的配置方式和上面的字符串配置一致。\n\n\nfavicon 图标#\n\n在 Rspress 中，你可以通过 icon 字段来指定站点的 favicon 图标。例如：\n\n\n\nicon 字段支持字符串配置，具体配置方式如下：\n\n * 配置为外链，如上面的例子。\n * 配置为绝对路径，如 /favicon.ico，这样 Rspress 在框架内部会自动在你的文档根目录的 public 目录中找到 favicon.ico\n   图标并进行展示。\n * 配置为相对路径，如 ./docs/public/favicon.ico，这样 Rspress 基于项目根目录寻找到 favicon.ico\n   图标并进行展示。\n\n\n主页 logo#\n\n在主页的 frontmatter 配置中，你可以通过 hero.image.src 字段来指定主页的 logo 图片。例如：\n\n\n\n其中，src 为一个字符串，支持如下的配置方式：\n\n * 配置为外链，如上面的例子。\n * 配置为绝对路径，如 /rspress-logo.png，这样 Rspress 在框架内部会自动在你的文档根目录的 public 目录中找到\n   rspress-logo.png 图片并进行展示。\n\n你可以在 markdown（或 mdx）文件中导入静态资源。相对路径和绝对路径都是支持的，例如，如果在 markdown\n同级目录有一张图片，你可以像这样引用它：\n\n\n.md(x) 中使用的静态资源#\n\n\n\n当然，在 .mdx 文件中你也可以直接使用 img 标签：\n\n\n\nRspress 将会根据 .mdx 文件路径和图片路径，自动找到图片并响应给浏览器。\n\n另一方面，也可以使用绝对路径导入静态资源。这样，Rspress 将会在文档根目录下的 public 文件夹中寻找资源。\n\n例如，如果根目录是 docs 并且目录结构如下\n\n\n\n在如上的 index.mdx 文件中，你可以像这样引用 demo.png：\n\n\n\n或者用绝对路径来引用：\n\n\n\n需要注意的一种特殊情况是，当你的站点配置了 base 路径，那么如果你要使用 img 标签的方式来引入绝对路径，你需要使用 rspress/runtime\n提供的 normalizeImagePath 来手动为其 src 添加 base 路径。示例如下：\n\n\n\n不光是图片，你也可以在 markdown 文件中引入视频、音频等静态资源。\n\n\n其它静态资源#\n\n部分场景下，你可能需要将某些特定的静态资源进行部署，比如添加 Netlify 的部署配置文件 _headers 指定自定义 HTTP 响应头。\n\n那么，你可以直接将这些静态资源放在文档根目录(如 docs)的 public 目录中，Rspress 在项目构建过程中会自动将 public\n目录的所有资源拷贝到产物目录。这样，public 下的资源就可以被部署到服务器上了。","routePath":"/zh/guide/basic/static-assets","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"左上角 logo","id":"左上角-logo","depth":2,"charIndex":206},{"text":"favicon 图标","id":"favicon-图标","depth":2,"charIndex":642},{"text":"主页 logo","id":"主页-logo","depth":2,"charIndex":927},{"text":"`.md(x)` 中使用的静态资源","id":"mdx-中使用的静态资源","depth":2,"charIndex":-1},{"text":"其它静态资源","id":"其它静态资源","depth":2,"charIndex":1645}],"domain":"","frontmatter":{},"version":""},{"id":59,"title":"使用 MDX","content":"#\n\nRspress 支持 MDX，这是一种功能强大的内容开发方式。\n\n\nMarkdown#\n\nMDX 是 Markdown 的超集，这意味着你可以像往常一样编写 Markdown 文件。例如：\n\n\n\n\n使用组件#\n\n当你想在 Markdown 文件中使用 React 组件时，你应该使用 .mdx 扩展名来命名你的文件。例如：\n\n\n\n\nFront Matter#\n\n你可以在 Markdown 文件的开头添加 Front Matter，它是一个 YAML 格式的对象，用于定义一些元数据。例如：\n\n\n\n> 注意：默认情况下，Rspress 使用 h1 标题作为 html 的标题。\n\n你还可以在正文中访问 Front Mattter 中定义的属性，例如：\n\n\n\n前面定义的属性将作为 frontmatter 属性传递给组件。所以最终输出将是：\n\n\n\n\n自定义容器#\n\n你可以使用 ::: 语法来创建自定义容器，且支持自定义标题。例如：\n\n输入：\n\n\n\n输出：\n\nTIP\n\n这是一个 tip 类型的 block\n\nINFO\n\n这是一个 info 类型的 block\n\nWARNING\n\n这是一个 warning 类型的 block\n\nDANGER\n\n这是一个 danger 类型的 block\n\nDETAILS\n\n这是一个 details of type block\n\n自定义标题\n\n自定义标题的 block\n\n自定义标题\n\n自定义标题的 block\n\n\n代码块#\n\n\n基本使用#\n\n你可以使用 ``` 语法来创建代码块，且支持自定义标题。例如：\n\n输入:\n\n\n\n输出:\n\n\n\n\n\n\n代码行高亮#\n\n你可以通过如下的语法指定代码行高亮，比如:\n\n输入:\n\n\n\n输出:\n\n\n\n你也可以同时应用代码行高亮和代码块标题，比如:\n\n输入:\n\n\n\n输出:\n\n\n\n\n显示代码行号#\n\n如果你想要显示代码行号，你可以在配置文件中开启 showLineNumbers 选项:\n\n\n\n\nWrap Code#\n\n如果你想要默认启用长代码换行展示，你可以在配置文件中开启 defaultWrapCode 选项:\n\n\n\n\n自定义锚点 id#\n\n默认情况下，Rspress 会根据各个标题的内容自动生成 id，这个 id 也会作为锚点的内容，你可以通过如下的语法来自定义 header 的 id:\n\n\n\n其中 custom-id 就是你自定义的 id。\n\n\n关闭 Rust 版本编译器#\n\n默认情况下，Rspress 使用 Rust 版本的 MDX 编译器，但是在某些情况下，你需要添加自定义的 MDX 编译插件，此时你可以通过如下的配置关闭\nRust 版本的 MDX 编译器，从而切换到 JavaScript 版本的编译器:\n\n是否使用 MDX 的 Rust 版本编译器，默认开启。比如：\n\n\n\n你也可以提供函数来决定哪些文件使用 MDX 的 Rust 版本编译器。比如：\n\n\n\n注意\n\nmdxRs 能力底层基于 Rspress 自研的 @rspress/mdx-rs 库来实现，性能比 JS 版本的 MDX 编译器提升 10 倍以上，但不支持\nJS 的插件。","routePath":"/zh/guide/basic/use-mdx","lang":"zh","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":36},{"text":"使用组件","id":"使用组件","depth":2,"charIndex":101},{"text":"Front Matter","id":"front-matter","depth":2,"charIndex":168},{"text":"自定义容器","id":"自定义容器","depth":2,"charIndex":376},{"text":"代码块","id":"代码块","depth":2,"charIndex":627},{"text":"基本使用","id":"基本使用","depth":3,"charIndex":634},{"text":"代码行高亮","id":"代码行高亮","depth":3,"charIndex":691},{"text":"显示代码行号","id":"显示代码行号","depth":3,"charIndex":776},{"text":"Wrap Code","id":"wrap-code","depth":3,"charIndex":833},{"text":"自定义锚点 id","id":"自定义锚点-id","depth":2,"charIndex":898},{"text":"关闭 Rust 版本编译器","id":"关闭-rust-版本编译器","depth":2,"charIndex":1015}],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"内置组件","content":"#\n\n\nBadge#\n\nBadge 组件用于展示状态的标记。使用方法如下：\n\n\n\n效果如下：\n\n其中包含的 props 类型如下：\n\n\n\n\nHelmet#\n\n一般用于在文档中设置自定义 head 内容(底层使用 react-helmet-async)。使用方法如下：\n\n\n\n\nHomeFeature#\n\nHome 页面 Feature 组件，查看本站的效果\n\n\n\n\nHomeHero#\n\nHome 页面 Hero 组件\n\n\n\n\nLastUpdated#\n\nLastUpdated 组件用来显示文章的最后更新时间。使用方法如下：\n\n\n\nTIP\n\n如果没有在默认主题中配置 lastUpdated: true 的话需要安装和注册 @rspress/plugin-last-updated 插件。\n\n\nNoSSR#\n\n用于在服务端渲染时不渲染某些组件。使用方法如下：\n\n\n\n\nOverview#\n\n预览组件，查看本站的效果\n\n\n\n\nPackageManagerTabs#\n\nPackageManagerTabs 组件用于在文档中展示不同包管理器的命令。使用方法如下：\n\n\n\n效果如下：\n\n其中包含的 props 类型如下：\n\n\n\n当 command 设置为字符串时，会默认展示 npm、yarn、pnpm、bun 四个 tab，并且组件内部为自动在 command\n前面添加对应的包管理器命令。如果你需要展示额外的 tab，可以通过 additionalTabs 来实现。\n\nTIP\n\n在 install 命令中，对 yarn 和 bun 做了特殊处理，如果你的命令是install some-packages，在 yarn 和 bun 的\ntab 中会自动将 install 替换为 add。\n\n\nPrevNextPage#\n\nPrevNextPage 组件用来渲染上一页和下一页的链接。使用方法如下：\n\n\n\n其中包含的 props 类型如下：\n\n\n\n\nSourceCode#\n\nSourceCode 组件用来跳转到源代码。使用方法如下：\n\n\n\n效果如下：\n\n其中包含的 props 类型如下：\n\n\n\n\nSteps#\n\nSteps 组件用于将编号列表转换为步骤的可视化表示形式。使用方法如下：\n\n\n\n效果如下:\n\n\nTab/Tabs#\n\n你可以在文档中直接使用 Tab/Tabs 组件来实现 tab 切换的效果。比如\n\n\n\n提醒\n\n为了让你更方便地使用这些组件，框架内部对于 rspress/theme 这个包做了 alias 处理，所以你可以直接使用 @theme 来引入这些组件。\n\n其中 Tabs 组件的 props 类型如下:\n\n\n\ndefaultValue 用于设置默认选中的 tab 项，这个值会和 Tab 组件的 value 字段做比较，如果相等则选中该 tab。\n\ngroupId 用于设置 tab 项的分组，当你需要多个 Tabs 组件进行联动的时候，可以通过 groupId 来实现。groupId 相同的 Tabs\n组件会进行联动。\n\ntabPosition 用于设置 tab 列表的排列位置，目前支持 left 和 center 两个值，分为表示靠左和居中，默认为 left。\n\nTab 组件的 props 类型如下:\n\n\n\n其中的 value 字段用于标识当前 tab，如果不传则默认使用 label。\n\n\nTable of Contents#\n\n渲染当前页面的 TOC\n\n","routePath":"/zh/guide/default-theme/components","lang":"zh","toc":[{"text":"Badge","id":"badge","depth":2,"charIndex":3},{"text":"Helmet","id":"helmet","depth":2,"charIndex":69},{"text":"HomeFeature","id":"homefeature","depth":2,"charIndex":137},{"text":"HomeHero","id":"homehero","depth":2,"charIndex":182},{"text":"LastUpdated","id":"lastupdated","depth":2,"charIndex":213},{"text":"NoSSR","id":"nossr","depth":2,"charIndex":347},{"text":"Overview","id":"overview","depth":2,"charIndex":384},{"text":"PackageManagerTabs","id":"packagemanagertabs","depth":2,"charIndex":412},{"text":"PrevNextPage","id":"prevnextpage","depth":2,"charIndex":746},{"text":"SourceCode","id":"sourcecode","depth":2,"charIndex":824},{"text":"Steps","id":"steps","depth":2,"charIndex":899},{"text":"Tab/Tabs","id":"tabtabs","depth":2,"charIndex":955},{"text":"Table of Contents","id":"table-of-contents","depth":2,"charIndex":1414}],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"正文页面","content":"#\n\n\n页面类型#\n\n你可以在 frontmatter 元数据中指定 pageType，以便在页面中使用不同的布局。默认情况下，文档的 pageType 是\ndoc，这样会默认出现左边的侧边栏和右侧的大纲栏。如果你不需要这些，可以将 pageType 设置为 custom:\n\n\n\n\n侧边栏#\n\n在 rspress.config.ts 中，你可以配置侧边栏的内容，具体可参考 API-侧边栏配置。\n\n\n大纲栏标题#\n\n通过 outlineTitle 配置项，你可以设置大纲栏的标题。\n\n\n\n\n上一页/下一页文本#\n\n通过 prevText 和 nextText 配置项，你可以设置上一页/下一页的文本。\n\n","routePath":"/zh/guide/default-theme/doc-page","lang":"zh","toc":[{"text":"页面类型","id":"页面类型","depth":2,"charIndex":3},{"text":"侧边栏","id":"侧边栏","depth":2,"charIndex":141},{"text":"大纲栏标题","id":"大纲栏标题","depth":2,"charIndex":200},{"text":"上一页/下一页文本","id":"上一页下一页文本","depth":2,"charIndex":245}],"domain":"","frontmatter":{},"version":""},{"id":62,"title":"Home 主页","content":"#\n\n你可以通过 frontmatter 来定义 Home 页面的内容，详细类型可见 FrontMatter 配置。下面是一个简单的例子：\n\n","routePath":"/zh/guide/default-theme/home-page","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"国际化","content":"#\n\n在 Rspress 中实现文档的国际化，你需要做如下的操作:\n\n 1. 定义 I18n 文本数据。\n 2. 配置 locales 和 themeConfig.locales。\n 3. 配置默认语言。\n 4. 新建不同的语言版本的文档。\n 5. 配置侧边栏和导航栏。\n 6. 自定义组件中使用 useI18n。\n\n\n定义 I18n 文本数据#\n\n在当前工作区新建 i18n.json，目录结构如下：\n\n\n\n在这个 JSON 文件中，你可以定义国际化所需的文本，类型定义如下:\n\n\n\n举个例子:\n\n\n\n这些文本数据在配置文件和自定义组件中都会用到，后文会详细介绍。\n\n\n配置 locales 数据#\n\n在 rspress.config.ts中，你可以通过两个地方来配置 locales 数据:\n\n * locales，用于配置站点的语言、标题、描述等信息，主要围绕站点本身的信息来配置。\n * themeConfig.locales，用于配置主题的语言、大纲栏标题、上一页/下一页文本等信息，主要进行主题相关的配置。\n\n\n\n注意\n\n默认主题中， themeConfig.locales 也包含 locales 中的所有字段，前者优先级更高。\n\n对于其它的国际化主题参数配置，请参考 API 类型。\n\n\n配置默认语言#\n\n在配置完 locales 之后，你需要通过 lang 配置文档的默认语言，如下例子所示:\n\n\n\n这很重要，因为对于默认语言下的路由，框架会去掉语言前缀，比如 /zh/guide/getting-started 会被转换为\n/guide/getting-started。\n\n\n新建不同的语言版本的文档#\n\n在做好上面的配置后，我们就可以开始新建不同语言版本的文档了，非常简单，我们只需要在文档根目录下新建如下的结构即可：\n\n\n\n可以看到，我们把不同语言的文档放在了 docs 目录下的 en 和 zh 目录中，这样就可以方便地区分不同语言的文档了。\n\n\n配置 _meta.json#\n\n通过 _meta.json 文件，我们可以配置导航栏和侧边栏的内容，具体可以参考自动化导航栏/侧边栏。\n\n\n导航栏级别#\n\n在导航栏级别的 _meta.json 配置中，你可以将 text 指定为 i18n key，比如:\n\n\n\n其中，text 为 guide，这个值会被自动翻译为 指南 或者 Guide，具体取决于当前语言。\n\n\n侧边栏级别#\n\n在侧边栏级别的 _meta.json 配置中，你可以将 label 指定为 i18n key，比如:\n\n\n\n其中，label 为 getting-started，这个值会被自动翻译为 开始 或者 Getting Started，具体取决于当前语言。\n\n\n自定义组件中使用 useI18n#\n\n在 MDX 开发或者自定义主题开发的过程中，你可能会写一些自定义组件，这些组件中也需要使用到国际化文本，那么如何获取呢？\n\n框架提供了 useI18n 这个 hook 来获取国际化文本，使用方式如下：\n\n\n\n为了获得更好的类型提示，你可以在 tsconfig.json 中配置 paths:\n\n\n\n然后在组件中这样使用:\n\n\n\n这样你就可以获得 i18n.json 中定义的所有文本 key 的类型提示了。","routePath":"/zh/guide/default-theme/i18n","lang":"zh","toc":[{"text":"定义 I18n 文本数据","id":"定义-i18n-文本数据","depth":2,"charIndex":159},{"text":"配置 `locales` 数据","id":"配置-locales-数据","depth":2,"charIndex":-1},{"text":"配置默认语言","id":"配置默认语言","depth":2,"charIndex":551},{"text":"新建不同的语言版本的文档","id":"新建不同的语言版本的文档","depth":2,"charIndex":697},{"text":"配置 _meta.json","id":"配置-_metajson","depth":2,"charIndex":836},{"text":"导航栏级别","id":"导航栏级别","depth":3,"charIndex":906},{"text":"侧边栏级别","id":"侧边栏级别","depth":3,"charIndex":1019},{"text":"自定义组件中使用 `useI18n`","id":"自定义组件中使用-usei18n","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":64,"title":"多版本文档","content":"#\n\nRspress 的默认主题中支持多版本文档管理，接下来，我们将介绍如何接入多版本文档。\n\n\nmultiVersion 配置#\n\n通过 multiVersion 配置版本列表和默认版本，比如：\n\n\n\n其中，default 为默认版本，versions 为版本列表。\n\n\n添加多版本文档#\n\n根据你配置的版本列表，在 docs 目录下，添加多版本文档，比如：\n\n\n\n在 Rspress 的约定式路由中，对于默认版本，会自动省略掉版本的路径前缀。如 v1/README.md 会被渲染为 /README 路由，而\nv2/README.md 会被渲染为 /v2/README 路由。\n\n提示\n\n对于文档中的链接，你不需要手动添加版本前缀，Rspress 会自动根据当前文档的版本，添加对应的版本前缀。如 v2/README.md 中的链接\n/guide/README 会被渲染为 /v2/guide/README。\n\n\n组件中获取当前版本#\n\n在组件中，你可以通过 useVersion 获取当前版本，比如：\n\n","routePath":"/zh/guide/default-theme/multi-version","lang":"zh","toc":[{"text":"`multiVersion` 配置","id":"multiversion-配置","depth":2,"charIndex":-1},{"text":"添加多版本文档","id":"添加多版本文档","depth":2,"charIndex":136},{"text":"组件中获取当前版本","id":"组件中获取当前版本","depth":2,"charIndex":408}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"导航栏模块","content":"#\n\n导航栏对一个网站来说非常重要，它可以让用户快速的在网站的不同页面之间进行跳转，也可以让用户快速的找到网站的一些重要信息。\n\n\n自定义导航菜单#\n\n你可以在 themeConfig.nav 中添加自定义的导航菜单，配置为一个数组，如下：\n\n\n\n导航栏配置为一个数组，数组中的每一项都是一个 NavItem 对象，它具有以下类型：\n\n\n\n也就是说，每个导航栏元素( NavItem )可以是一个链接( NavItemWithLink )，也可以是一个包含子元素的导航栏组(\nNavItemWithChildren )。\n\n\nNavItemWithLink#\n\n\n\n其中各项属性的含义如下:\n\n * text - 导航栏文本\n * link - 导航栏链接\n * activeMatch - 导航栏链接的激活规则\n * position - 导航栏菜单项定位\n\n属性详情：\n\nactiveMatch 用于匹配当前路由，当路由匹配 activeMatch 规则时，nav 项会高亮显示。\n\n> 默认情况下，activeMatch 是 NavItem 的 link 属性。\n\nposition 用于配置顶部菜单项的独立定位，可选项为：\n\n * 'left'：置于菜单项到顶部的左侧菜单栏；\n * 'right'：置于菜单项到顶部的右侧菜单栏。\n\n> 如果 position 未配置的情况下会默认放到右侧菜单栏，效果等同于配置 'right'。\n\n\nNavItemWithChildren#\n\n\n\n其中各项属性的含义如下:\n\n * text - 导航栏文本\n * items - 子导航栏元素\n * position- 带有子元素的导航栏菜单项定位\n\n\n示例#\n\n\n\n\n白天/夜间模式#\n\n默认情况下导航栏会带上 白天/夜间 模式的切换按钮，你可以通过如下的配置禁用：\n\n\n\n\n相关链接#\n\n网站的社交链接。比如：\n\n\n\n更多配置请参考链接。","routePath":"/zh/guide/default-theme/navbar","lang":"zh","toc":[{"text":"自定义导航菜单","id":"自定义导航菜单","depth":2,"charIndex":65},{"text":"NavItemWithLink","id":"navitemwithlink","depth":3,"charIndex":262},{"text":"NavItemWithChildren","id":"navitemwithchildren","depth":3,"charIndex":621},{"text":"示例","id":"示例","depth":3,"charIndex":723},{"text":"白天/夜间模式","id":"白天夜间模式","depth":2,"charIndex":731},{"text":"相关链接","id":"相关链接","depth":2,"charIndex":785}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"预览页","content":"#\n\n\n效果#\n\nRspress 内置一套预览页，效果如下:\n\n\n如何开启？#\n\n生成预览页需要如下两步:\n\n\n1. 新建目录，配置 frontmatter#\n\n比如新建如下的目录和文件:\n\n\n\n我们在 api/index.md 中添加如下内容:\n\n\n\n\n2. 配置 _meta.json#\n\n预览页面的内容结构会根据 _meta.json 及其对应文章的 h1、h2 标题自动生成。比如 api/_meta.json 的配置如下：\n\n\n\n同时，api/theme/_meta.json 的文件，内容如下：\n\n\n\n> _meta.json 的详细配置用法可以参考自动化导航栏/侧边栏。\n\n在如上的配置中，最后预览页会生成一个 Theme 的分组，这个分组里面包含 component.md(x) 和 utils.md(x) 两篇文章的 h1、h2\n标题。当然，你也可以参考 Theme 分组的配置，添加更多的分组。","routePath":"/zh/guide/default-theme/overview-page","lang":"zh","toc":[{"text":"效果","id":"效果","depth":2,"charIndex":3},{"text":"如何开启？","id":"如何开启","depth":2,"charIndex":32},{"text":"1. 新建目录，配置 frontmatter","id":"1-新建目录配置-frontmatter","depth":3,"charIndex":55},{"text":"2. 配置 `_meta.json`","id":"2-配置-_metajson","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"快速开始","content":"#\n\n\n1. 初始化项目#\n\n\n方式一：通过脚手架创建#\n\n你可以通过 Rspress 脚手架命令来创建项目:\n\n然后按照提示输入项目名称，即可创建一个 Rspress 项目。\n\n\n方式二：手动创建#\n\n首先，你可以通过以下命令创建一个新目录：\n\n\n\n执行 npm init -y 来初始化一个项目。你可以使用 npm、yarn 或 pnpm 安装 Rspress:\n\n然后通过如下命令创建文件:\n\n\n\n在 package.json 中加上如下的脚本:\n\n\n\n然后初始化一个配置文件 rspress.config.ts:\n\n\n\n同时新建 tsconfig.json，内容如下:\n\n\n\n\n2. 启动 Dev Server#\n\n通过如下命令启动本地开发服务:\n\n\n\n这样 Rspress 将启动开发服务。\n\n提示\n\n对于 dev 命令，你可以通过 --port 或 --host 参数来指定开发服务的端口号或 host，例如 rspress dev --port 8080\n--host 0.0.0.0。\n\n\n3. 生产环境构建#\n\n通过如下命令构建生产环境的产物:\n\n\n\n默认情况下，Rspress 将会把产物打包到 doc_build 目录。\n\n\n4. 本地预览产物#\n\n通过如下命令启动本地预览服务:\n\n\n\n这样 Rspress 将启动产物预览服务。","routePath":"/zh/guide/start/getting-started","lang":"zh","toc":[{"text":"1. 初始化项目","id":"1-初始化项目","depth":2,"charIndex":3},{"text":"方式一：通过脚手架创建","id":"方式一通过脚手架创建","depth":3,"charIndex":15},{"text":"方式二：手动创建","id":"方式二手动创建","depth":3,"charIndex":90},{"text":"2. 启动 Dev Server","id":"2-启动-dev-server","depth":2,"charIndex":292},{"text":"3. 生产环境构建","id":"3-生产环境构建","depth":2,"charIndex":452},{"text":"4. 本地预览产物","id":"4-本地预览产物","depth":2,"charIndex":523}],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"介绍","content":"#\n\n\n定位#\n\nRspress 是一个基于 Rspack 的静态站点生成器，基于 React 框架进行渲染，内置了一套默认的文档主题，你可以通过 Rspress\n来快速搭建一个文档站点，同时也可以自定义主题，来满足你的个性化静态站需求，比如博客站、产品主页等。当然，你也可以接入官方提供的相应插件来方便地搭建组件库文档。\n\n\n项目背景#\n\nRspress 主要以如下的几个方向来进行建设：\n\n * 构建性能。保证足够快的启动速度，带来良好的开发体验。\n * MDX 支持。通过 MDX，我们可以方便地复用文档片段，以及在文档中渲染自定义的 React 组件。\n * 文档站基础能力。包括国际化、多版本支持、全文搜索、组件库文档等。\n * 可扩展性。内置插件系统，支持通过插件 API 来扩展框架功能。\n\n这些也代表了 SSG 站点开发的一些核心需求。接下来将会根据这几个方面分别进行介绍。\n\n\n构建性能#\n\n当项目越来越庞大，团队成员时常苦恼于冗长的项目启动时间，开发体验因此受到了一些负面影响，并且项目开发的时间越长，这种体验的劣化就越为明显。\n\n我们不禁开始思考，是否能跳出目前社区工具链的限制，突破现有 SSG 框架的性能瓶颈，实现绝大多数场景的项目秒启效果？\n\n接着，我们在这个方向上持续地探索，最终在 Rspress 上实现了这样的效果。以 Rspress 官网文档的内容为例，Rspress、Docusaurus 和\nNextra 三者的性能对比情况如下：\n\n如果只说一种最核心的优化手段，那无疑是 Rust 前端工具链。 我们主要在两个性能敏感部分使用了 Rust 工具链：\n\n * 前端 Bundler。传统的 Bundler 包括 webpack、Rollup 等等，对于一个前端工程而言，bundler\n   是各个编译工具链的集成枢纽，是一个非常关键的工程能力，对项目构建性能影响巨大。而 Rspress 使用了团队内部自研的 Rspack，Rspack\n   是一个基于 Rust 的 Bundler，内置多种性能优化手段，比如多线程并行编译、增量编译等等，相比社区传统的打包工具，有 5 ～ 10 倍的性能提升。\n * Markdown 编译器。对于 SSG 框架中另一大编译性能瓶颈，即Markdown 编译，我们也将这一流程 Rust 化以进一步提速，定制出\n   Rspress 的 Markdown 编译器（即@rspress/mdx-rs）。这款编译器相比社区的 JS 版本的编译器，有近 20 倍的性能提升：\n\n与此同时，Rspress 内部也应用了其它的诸多构建优化手段，比如主题包预打包、样式预生成 等等。这些额外的优化手段，配合强有力的 Rust 工具链，将 SSG\n框架的编译性能推向了一个崭新的高度。\n\n\nMDX 支持#\n\n为了保证内容开发的灵活性，Rspress 选择支持 MDX 这种内容格式。\n\n因为 MDX 的背后实际代表了一种组件化的内容组织方式，一方面文档即组件，那么我们可以在不同文档间复用文档片段，另一方面在文档中可以引入任何自定义 React\n组件，大大释放了文档开发的想象力。\n\n\n文档站基础能力#\n\n当然，Rspress 在文档站基础能力的打磨上也做了相当多的工作，支持了如下的功能特性：\n\n * 自动生成布局，包括导航栏、左侧侧边栏等等；\n * 静态站点生成，项目构建后直出 HTML；\n * 国际化，支持多语言文档；\n * 全文搜索，提供开箱即用的搜索功能；\n * 多版本文档管理；\n * 自定义文档主题；\n * 自动生成组件 Demo 预览及 Playground；\n\n在后文，我们将会对这些功能特性进行详细的介绍。\n\n\n扩展机制#\n\nRspress 内部设计了多种扩展机制，保证足够强的定制能力，包括：\n\n * 支持自定义全局组件、全局样式、页面布局结构，详情请参考自定义页面。\n * 支持构建能力扩展，包括 Rspack 配置、增加 MDX 编译插件等等，详情请参考构建能力扩展。\n * 支持自定义主题，详情请参考自定义主题。\n * 内置插件机制，支持自定义插件，详情请参考插件机制。\n\n\n功能特性#\n\n接下来我们来介绍 Rspress 的主要功能特性。\n\n\n自动生成布局#\n\n对于一个文档站的搭建而言，除了显示正文内容之外，我们一般还需要以下的几个布局模块：\n\n * 导航栏，用于提供全局性的导航入口；\n * 侧边栏，用于展示当前导航下的文章目录；\n * 文章大纲栏，用于展示当前页面的大纲结构。\n\n对于文档大纲，Rspress 会自动提取文档中的各级标题，生成大纲信息，并默认展示在文章页右侧，你无需其它操作。\n\n而对于导航栏和侧边栏，我们提供了两种配置方式，你可以选择其中一种进行配置：\n\n * 声明式配置。通过在目录中声明 _meta.json 来配置对应的数据，比如：\n\n\n\n配置详情你可以阅读「自动化导航栏/侧边栏」文档。\n\n * 编程式配置。通过在 Rspress 配置中指定 nav 和 sidebar 配置项来实现。\n\n我们推荐在一般情况下使用声明式配置，这样有诸多的好处：\n\n 1. 配置文件更加简洁和清晰。\n 2. 文件目录结构和侧边栏目录结构的对应关系更加直观。\n 3. 增加或者删减侧边栏目录时，直接在当前目录中操作，而不用前往 rspress.config.ts\n    配置文件中定位到相应的位置然后添加/删减配置，从而减少了开发上下文切换的成本。\n\n而编程式配置则在某些需要动态生成配置的场景中非常有用，比如 Rspress 官方的 TypeDoc 插件 会根据 TypeDoc 提供的一份 json\n数据自动转换为 nav 和 sidebar 的配置。\n\n\nMDX 支持#\n\nMDX 是一种功能强大的内容开发方式。你不仅仅可以像往常一样编写 Markdown 文件，而且可以在 Markdown 的内容中使用 React 组件：\n\n除此之外，Rspress 还支持了一些特定的语法，如：\n\n * 自定义容器语法。\n * FrontMatter 元数据定义。\n * 代码行高亮语法。\n\n详情可以查看「使用 MDX」 文档。\n\n\nSSG#\n\nRspress 是一个标准的 SSG 框架，在生产环境的构建中，它会自动帮你生成静态站点，即生成各个页面的 HTML 内容，在构建完成之后，HTML\n会出现在默认的产物目录中。\n\n随后，你可以将这个产物目录的内容部署到任何静态站点托管服务上，比如 Github Pages、Netlify、Vercel 等等。\n\n同时，我们也提供了配置让你能够很方便地自定义 SSG 生成的 HTML 内容，详情可以参考「静态站点生成」文档。\n\n\n国际化（i18n）#\n\n国际化在一个文档类型的站点中是一个很常见的需求，而 Rspress 将国际化的能力封装得足够简单易用，在框架中我们将国际化抽象为如下的需求：\n\n * 如何定义 I18n 数据源？\n * 如何进行不同语言下的站点配置？\n * 如何组织不同语言版本的文档目录？\n * 如何自定义组件中使用 I18n 数据源？\n\n框架已经为你支持了这些需求场景，你可以根据 I18n 教程 来一步步为你的站点实现国际化。\n\n\n多版本文档#\n\n在某些场景中，我们需要进行多版本文档管理，而 Rspress\n已经内置了多版本文档的支持，一方面你可以通过简单的配置来开启这个能力，另一方面你只需要按照往常的写法来组织目录即可，不引入非必要的目录和概念，将心智负担降到最低\n：\n\n\n\n\n\n\n全文搜索#\n\nRspress 中提供开箱即用的全文搜索能力，你无需任何配置即可接入，底层基于开源的 FlexSearch 引擎实现，效果如下：\n\n\n自定义主题#\n\nRspress 支持两种自定义主题的方式：\n\n 1. 基于默认主题扩展。在默认主题的各个组件中，提供了许多插槽让你能添加自定义的布局内容，比如\n\n\n\n 2. 完全自定义主题。如果你想从头开发一套自定义主题，可以重新自定义 Layout 的内容，并借助 Rspress 提供的各个 Runtime API （如\n    usePageData）来获取编译时数据、路由等信息。\n\n关于自定义主题的详情，你可以参考「自定义主题」文档。\n\n\n插件机制#\n\n插件机制是 Rspress 至关重要的部分，它可以让你在搭建站点的过程中，方便地扩展框架的功能。详情可以查看插件介绍文档。\n\n\n组件文档#\n\nDemo 预览#\n\nRspress 提供了 preview 插件，可以自动为你生成组件预览。当你注册 preview 插件后，在 mdx 文件中声明如下的代码块：\n\n\n\n那么你可以看到如下的预览效果：\n\n\n\n当然，插件同时也支持移动端预览模式，你可以通过插件配置开启，预览效果如下：\n\n\n\nDemo 实时 Playground#\n\n对于组件文档，如果能提供组件的实时编辑的能力，将能大大提高文档的交互体验。\n\n为了实现这个功能，你只需要注册官方的 playground 插件，然后在 .mdx 文件中声明你的代码块。（这里以上面的代码块为例）\n\n接着，你将会在文档中看到下面的 playground 效果：\n\n\n\n\n内置流畅的转场动画#\n\nView Transition API 是现代浏览器原生提供的一组 API，用于实现页面跳转过程中的过渡效果。在 Rspress 中我们也跟进了这个特性，基于\nView Transition 实现了文档的过渡动画，而未使用任何第三方 SPA 的动画方案。在未来，我们也会探索出更多的动画效果，进一步提升体验。\n\n\n\n\n与其它 SSG 框架的区别#\n\n\n与 Docusaurus 的区别#\n\nDocusaurus 是 Meta 开源的一款 SSG 框架，它和 Rspress 一样使用 React 作为渲染框架，且支持 MDX，但 Rspress 与\nDocusaurus 的区别主要在于：\n\n 1. Rspress 的构建性能更好。Rspress 基于 Rust 前端工具链，项目启动/构建速度快于 Docusaurus 5 ~ 10\n    倍，详情可以参考构建性能。\n 2. Rspress 的配置更简单，上手成本更低。Rspress\n    的配置更加简单，不引入过多的概念，尽可能降低心智负担，比如提供开箱即用的搜索功能、符合直觉的多版本文档管理方式等等。\n 3. Rspress 架构上对 Bundler 提供了更上层的抽象。对于 webpack、Rspack 这类底层的\n    Bundler，其配置项繁琐且不易上手。Docusaurus 选择直接暴露底层 Bundler 的配置项，而 Rspress 则对 Bundler\n    进行了更上层的抽象，提供了更加简单易用的配置项，比如你可以通过 builderConfig.html.tags 轻松添加 中的标签，而不用通过\n    Bundler 来注册 html-webpack-plugin 相关插件。\n\n\n与 Nextra 的区别#\n\nNextra 是 Vercel 开源的一款 SSG 框架，它也和 Rspress 一样使用 React 作为渲染框架，且支持 MDX。Rspress 与\nNextra 的区别主要在于：\n\n 1. Rspress 的构建性能更好。这一点可参考「与 Docusaurus 的区别」。\n 2. Rspress 整体更加轻量。Nextra 需要依赖 Next.js，其 SSG 流程也是基于 Next.js 的，因此 SSG 产物中并非纯粹的\n    HTML 文件，而是额外包含了一些 Next.js 的运行时代码，一方面导致了 Nextra 的产物体积更大，另一方面需要在部署时以应用的方式部署(使用\n    next start 命令)，而不能以纯静态站点的方式部署。但 Rspress\n    没有和任何应用框架绑定，因此产物更加轻量，可以很方便地以纯静态站点的方式部署。\n\n\n与 VitePress 的区别#\n\nVitePress 是一款基于 Vite 静态站点生成器，它的特点是使用 Vue 作为渲染框架，且性能非常优秀。Rspress 与 VitePress\n的区别主要在于：\n\n 1. Rspress 使用 React 作为渲染框架，而 VitePress 使用 Vue 作为渲染框架。\n 2. Rspress 使用 MDX 作为内容开发方式，而 VitePress 使用 Markdown 作为内容开发方式，并在 Markdown 中支持 Vue\n    组件，这同时也导致了底层编译工具链实现上的差异。\n 3. 构建性能上，在开发阶段，Rspress 和 VitePress 都能很快地启动一个项目，而在生产环境下，VitePress 需要基于 Rollup\n    打包项目，因此会面临其他基于 JavaScript 的工具链类似的性能问题，此时 Rspress 会有更快的构建速度。\n\n\n尝试 Rspress#\n\n进入快速开始了解如何使用 Rspress 快速搭建一个文档站点。","routePath":"/zh/guide/start/introduction","lang":"zh","toc":[{"text":"定位","id":"定位","depth":2,"charIndex":3},{"text":"项目背景","id":"项目背景","depth":2,"charIndex":163},{"text":"构建性能","id":"构建性能","depth":3,"charIndex":397},{"text":"MDX 支持","id":"mdx-支持","depth":3,"charIndex":1177},{"text":"文档站基础能力","id":"文档站基础能力","depth":3,"charIndex":1325},{"text":"扩展机制","id":"扩展机制","depth":3,"charIndex":1549},{"text":"功能特性","id":"功能特性","depth":2,"charIndex":1735},{"text":"自动生成布局","id":"自动生成布局","depth":3,"charIndex":1770},{"text":"MDX 支持","id":"mdx-支持-1","depth":3,"charIndex":2386},{"text":"SSG","id":"ssg","depth":3,"charIndex":2570},{"text":"国际化（i18n）","id":"国际化i18n","depth":3,"charIndex":2792},{"text":"多版本文档","id":"多版本文档","depth":3,"charIndex":3006},{"text":"全文搜索","id":"全文搜索","depth":3,"charIndex":3134},{"text":"自定义主题","id":"自定义主题","depth":3,"charIndex":3208},{"text":"插件机制","id":"插件机制","depth":3,"charIndex":3433},{"text":"组件文档","id":"组件文档","depth":3,"charIndex":3504},{"text":"Demo 预览","id":"demo-预览","depth":4,"charIndex":3511},{"text":"Demo 实时 Playground","id":"demo-实时-playground","depth":4,"charIndex":3656},{"text":"内置流畅的转场动画","id":"内置流畅的转场动画","depth":3,"charIndex":3819},{"text":"与其它 SSG 框架的区别","id":"与其它-ssg-框架的区别","depth":2,"charIndex":3990},{"text":"与 Docusaurus 的区别","id":"与-docusaurus-的区别","depth":3,"charIndex":4007},{"text":"与 Nextra 的区别","id":"与-nextra-的区别","depth":3,"charIndex":4571},{"text":"与 VitePress 的区别","id":"与-vitepress-的区别","depth":3,"charIndex":4975},{"text":"尝试 Rspress","id":"尝试-rspress","depth":2,"charIndex":5388}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"rspress-plugin-translate","content":"#\n\n使用 LLM 进行文件翻译的 Rspress 插件，目前仅支持 GPT。\n\n\n安装#\n\n\n使用#\n\n\n\n当你启动项目后，插件会根据你的文档根目录下的源语言文件夹里的文件调用 LLM 帮你自动翻译成目标语言，并存到目标语言文件夹中\n\n对于源语言文件夹里不需要翻译的文件，每次你启动项目后，也会自动复制到目标语言文件夹中\n\n注意，每次启动项目时插件都会对源语言文件夹里的文件做 hash cache，如果对比上一次 cache 发现有更新，则会进行重新翻译，反之则跳过这个文件\n\n\n参数说明#\n\n\nmodelConfig#\n\n * 类型: Object\n\nmodelConfig.clientOptions#\n\n * Type: ClientOptions {}\n\n调用 OpenAI 的客户端设置,可以传入 API-KEY、Agent 等, 具体可以前往类型声明查看所有支持的参数。\n\nmodelConfig.model#\n\n * Type: string\n * Default: gpt-3.5-turbo\n\n调用 OpenAI 的模型名称,你可以前往模型列表查看所有支持的模型名称。\n\n\nmatch#\n\n * 类型: Object\n\n自定义匹配需要翻译文件的配置。\n\nmatch.exclude#\n\n * Type: string[]\n * Default: []\n\n不翻译某些文件。例如：\n\n\n\n> 注意：数组中的字符串支持 glob 模式。\n\nmatch.extensions#\n\n * Type: string[]\n * Default: []\n\n将包含在翻译流程中的文件的扩展名。默认情况下，Rspress 会在路由中包含所有 'md', 'mdx' 文件。如果你想自定义扩展名，你可以使用这个选项。例如：\n\n\n\n\nrateLimitPerMinute#\n\n * 类型: Number\n * 默认值：3\n\n大模型速率限制, 默认每分钟 3 次请求。\n\n\ngetPrompt#\n\n * 类型: Function\n\n大模型 Prompt 提示函数，它接收三个参数：content（源语言文件内容）、from（源语言名称）和\nto（目标语言名称）。该函数的返回将作为调用大模型传入的 prompt 参数。例如：\n\n","routePath":"/zh/plugin/community-plugins/translate","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":41},{"text":"使用","id":"使用","depth":2,"charIndex":47},{"text":"参数说明","id":"参数说明","depth":2,"charIndex":241},{"text":"modelConfig","id":"modelconfig","depth":3,"charIndex":249},{"text":"modelConfig.clientOptions","id":"modelconfigclientoptions","depth":4,"charIndex":278},{"text":"modelConfig.model","id":"modelconfigmodel","depth":4,"charIndex":394},{"text":"match","id":"match","depth":3,"charIndex":497},{"text":"match.exclude","id":"matchexclude","depth":4,"charIndex":537},{"text":"match.extensions","id":"matchextensions","depth":4,"charIndex":627},{"text":"rateLimitPerMinute","id":"ratelimitperminute","depth":3,"charIndex":765},{"text":"getPrompt","id":"getprompt","depth":3,"charIndex":834}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"@rspress/plugin-api-docgen","content":"#\n\n用于自动生成 API 文档，支持 react-docgen-typescript 和 documentation。\n\n\n安装#\n\n\n使用#\n\n首先在配置文件中写入以下的配置：\n\n\n\n然后你可以在 MDX 中使用 API 组件将 API 内容注入到文档中：\n\n\n\n\n配置#\n\n这个插件接受一个对象参数，类型如下:\n\n\n\n\nappDir#\n\nappDir用来配置插件解析文件的基准目录，默认为 process.cwd()\n\n\nentries#\n\nentries 用来配置解析文件的基本信息：\n\n * key 为标识符，作为 API 组件的 moduleName属性\n * value 为解析文件的相对路径\n\n\napiParseTool#\n\napiParseTool 用来选择解析工具，默认为react-docgen-typescript：\n\n * react-docgen-typescript针对于组件库场景，仅会解析 props 生成表格。\n\n\n\n上面是一个标准写法，其中 ButtonProps 将被提取至表格中， Button 作为表格的标题。 如果使用默认导出，文件名将作为表格标题。\n\n需要注意的是，export 导出事先定义的特性将不会被解析。\n\n\n\n生成的内容如下：\n\n\n\nWARNING\n\n如果 Props 里使用了 React 的类型，你需要在 tsconfig.json 里添加 types ，否则会解析不到 React 命名空间下的类型。\n\n\n\n更好的方式是直接引用类型，例如\n\n\n\n * documentation适用于工具库场景，用来解析 JSDoc 注释。 下面是一个带有 JSDoc 注释的 greet 函数。\n\n\n\n上面是一个带有 JSDoc 注释的 greet 函数。生成的内容如下：\n\n","routePath":"/zh/plugin/official-plugins/api-docgen","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":62},{"text":"使用","id":"使用","depth":2,"charIndex":68},{"text":"配置","id":"配置","depth":2,"charIndex":134},{"text":"appDir","id":"appdir","depth":3,"charIndex":162},{"text":"entries","id":"entries","depth":3,"charIndex":213},{"text":"apiParseTool","id":"apiparsetool","depth":3,"charIndex":305}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"@rspress/container-syntax","content":"#\n\nRspress 的内置插件，主要有两个作用：\n\n * 解析 Markdown/MDX 中的 container 语法，如 :::tip、:::warning，将其编译为 JSX 语法。\n * 给 container 块添加样式。","routePath":"/zh/plugin/official-plugins/container-syntax","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"@rspress/plugin-last-updated","content":"#\n\n\n介绍#\n\n@rspress/plugin-last-updated 是一个用于在文章中显示最后更新时间的插件。\n\n提示\n\n当你在默认主题中配置了 lastUpdated: true 时，该插件会自动生效，不需要你去安装和注册插件。\n\n\n安装#\n\n\n使用#\n\n\n1. 注册插件#\n\n\n\n\n2. 运行时访问#\n\n注册插件后，你就可以在运行时拿到文章的最后更新时间戳了。示例如下：\n\n","routePath":"/zh/plugin/official-plugins/last-updated","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"安装","id":"安装","depth":2,"charIndex":121},{"text":"使用","id":"使用","depth":2,"charIndex":127},{"text":"1. 注册插件","id":"1-注册插件","depth":3,"charIndex":133},{"text":"2. 运行时访问","id":"2-运行时访问","depth":3,"charIndex":146}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"@rspress/plugin-medium-zoom","content":"#\n\n默认内置插件，用于支持图片放大。\n\n\n配置#\n\n由于该插件是内置插件，所以不需要在配置文件手动注册，只需要在 mediumZoom 字段中配置即可。比如：\n\n\n\n\nselector#\n\n * 类型: string\n * 默认值: .rspress-doc img\n\n自定义图片选择器。\n\n\noptions#\n\n * 类型: ZoomOptions\n * 默认值: {}\n\nmedium-zoom 的配置项，点击进入配置详情。","routePath":"/zh/plugin/official-plugins/medium-zoom","lang":"zh","toc":[{"text":"配置","id":"配置","depth":2,"charIndex":21},{"text":"selector","id":"selector","depth":3,"charIndex":84},{"text":"options","id":"options","depth":3,"charIndex":147}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"总览","content":"#\n\n\n官方插件#\n\n官方插件包括:\n\n * @rspress/plugin-medium-zoom：medium-zoom 集成插件，用于支持 MediumZoom 图片放大效果。\n * @rspress/plugin-last-updated：支持显示最后更新时间。\n * @rspress/plugin-container-syntax：支持在 Markdown/MDX 中使用 ::: container 语法。\n * @rspress/plugin-typedoc：TypeDoc 集成插件，用于自动生成 TS 模块的 API 文档。\n * @rspress/plugin-preview：支持代码块中的组件预览。\n * @rspress/plugin-playground：支持代码块中的组件预览，并提供实时 Playground。\n * @rspress/plugin-shiki：集成 Shiki 来进行代码高亮的插件。\n\n\n社区插件#\n\n社区插件包括:\n\n * rspress-plugin-translate：集成 LLM 进行文档翻译的插件。","routePath":"/zh/plugin/official-plugins/overview","lang":"zh","toc":[{"text":"官方插件","id":"官方插件","depth":2,"charIndex":3},{"text":"社区插件","id":"社区插件","depth":2,"charIndex":420}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"@rspress/plugin-playground","content":"#\n\n提供一个可实时编辑的 Playground 以预览 mdx 文件代码块中的组件。\n\n\n安装#\n\n\n使用#\n\n\n引入插件#\n\n首先在配置文件中写入以下的配置：\n\n\n\n注意\n\n此插件会将 markdown.mdxRs 配置为 false，未来 Rspress 团队会将该插件移植到 Rust 版本的编译器中。\n\n\n内部组件#\n\n提示\n\n建议使用 js 或 jsx 编写示例代码，避免编辑器中出现 ts 类型报错问题。\n\n内部组件的组件代码声明在 mdx 文件内。支持 jsx 或 tsx。你可以在 mdx 文件中声明如下的代码块：\n\n\n\n另外，你可以通过 direction 参数，指定编辑器与预览区域的布局；支持 horizontal 或 vertical：\n\n\n\n值得注意的是，你需要将组件作为 default 导出，Rspress 会自动渲染这个组件。\n\n但是如果你想保留代码块的样式，而不是将其作为组件渲染，你可以添加 pure 标识符来指定，使用方式如下：\n\n\n\n如果你配置了 defaultRenderMode 为 'pure'，那么默认情况下，Rspress\n将不会渲染这个组件，而是将其作为代码块来渲染。这种情况下，如果需要将某个代码块渲染为组件，可以通过添加 playground 标识符来指定，使用方式如下：\n\n\n\n提示\n\n需要保证文档为 .mdx 结尾的文件。\n\n\n外部组件#\n\n除了将组件代码写在 mdx 文件的代码块中，你还可以将组件代码写在外部文件中，然后在 mdx 文件中通过 code 标签引入。比如\n\n\n\n\n\n同样的，外部组件也支持 direction 属性：\n\n\n\n外部组件中同样需要将组件作为 default 导出。而通过 code 标签的 src\n属性，你可以指定外部组件的路径，该插件同时支持相对路径以及别名路径(alias)。\n\n对于某些比较复杂的组件，这种外部组件的使用方式会更加方便。\n\n\n定义整个页面中的布局#\n\n可以在 frontmatter 中编写 playgroundDirection，来定义整个页面中编辑器与预览区域的布局。\n\n\n\n优先级：直接定义在预览区域上 > 页面定义 > 配置中定义。\n\n\n配置#\n\n这个插件接受一个对象参数，类型如下:\n\n\n\n注意\n\nmonacoLoader 及 monacoOptions 内部会被序列化为 JSON，因此不支持部分数据类型，如函数、循环引用的对象。\n\n\nrender#\n\n你可以自定义 render 文件，用于渲染 Playground；请注意，文件名必须为 Playground.(jsx?|tsx?)\n\n\n\n在自定义 Playground 中，你可以直接引用原始的编辑器和渲染器，以及通过 _rspress_playground_imports 引用提前打包好的依赖：\n\n\n\n可以参考自带的 Playground.tsx 进行自定义；\n\n\ninclude#\n\n默认情况下，该插件会自动扫描所有 demo 中的 import 语句；demo 中没有使用到的依赖，在 Playground\n中也无法使用；如果希望将其他依赖加入到 Playground 中，可以使用 include 参数：\n\n\n\n\nbabelUrl#\n\nPlayground 使用 @babel/standalone 对演示代码进行编译，默认从 cdnjs.com 加载。\n\n你可以修改为其他 CDN 提供的 URL，例如 unpkg、jsdelivr 等。\n\n\nmonacoLoader#\n\n配置 monaco-loader 相关行为。默认从 cdnjs.com 加载。\n\n你可以修改为其他 CDN 提供的 URL，例如 unpkg、jsdelivr 等。\n\n完整文档可见 suren-atoyan/monaco-loader\n\n\nmonacoOptions#\n\n配置 monaco editor，对应 IStandaloneEditorConstructionOptions\n\n\ndefaultRenderMode#\n\n支持用户配置没有主动声明 pure 或 playground 标识符的内部代码块的默认行为，默认为 playground。\n\n * pure: 渲染为普通代码块\n * playground: 渲染为 Playground 组件","routePath":"/zh/plugin/official-plugins/playground","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":45},{"text":"使用","id":"使用","depth":2,"charIndex":51},{"text":"引入插件","id":"引入插件","depth":3,"charIndex":57},{"text":"内部组件","id":"内部组件","depth":3,"charIndex":157},{"text":"外部组件","id":"外部组件","depth":3,"charIndex":594},{"text":"定义整个页面中的布局","id":"定义整个页面中的布局","depth":3,"charIndex":819},{"text":"配置","id":"配置","depth":2,"charIndex":929},{"text":"render","id":"render","depth":3,"charIndex":1030},{"text":"include","id":"include","depth":3,"charIndex":1225},{"text":"babelUrl","id":"babelurl","depth":3,"charIndex":1352},{"text":"monacoLoader","id":"monacoloader","depth":3,"charIndex":1468},{"text":"monacoOptions","id":"monacooptions","depth":3,"charIndex":1603},{"text":"defaultRenderMode","id":"defaultrendermode","depth":3,"charIndex":1678}],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"@rspress/plugin-preview","content":"#\n\n用于预览 md(x) 文件代码块中的组件。\n\n\n安装#\n\n\n使用#\n\n\n引入插件#\n\n首先在配置文件中写入以下的配置：\n\n\n\n注意\n\n此插件会将 markdown.mdxRs 配置为 false，未来 Rspress 团队会将该插件移植到 Rust 版本的编译器中。\n\n\n内部组件#\n\n内部组件的组件代码声明在 mdx 文件内。你可以在 mdx 文件中声明如下的代码块：\n\n\n\n值得注意的是，你需要将组件作为 default 导出，Rspress 会自动渲染这个组件。\n\n但是如果你想保留代码块的样式，而不是将其作为组件渲染，你可以添加 pure 标识符来指定，使用方式如下：\n\n\n\n如果你配置了 defaultRenderMode 为 'pure'，那么默认情况下，Rspress\n将不会渲染这个组件，而是将其作为代码块来渲染。这种情况下，如果需要将某个代码块渲染为组件，可以通过添加 preview 标识符来指定，使用方式如下：\n\n\n\n提示\n\n需要保证文档为 .mdx 结尾的文件。\n\n\n外部组件#\n\n除了将组件代码写在 mdx 文件的代码块中，你还可以将组件代码写在外部文件中，然后在 mdx 文件中通过 code 标签引入。比如\n\n\n\n\n\n外部组件中同样需要将组件作为 default 导出。而通过 code 标签的 src\n属性，你可以指定外部组件的路径，该插件同时支持相对路径以及别名路径(alias)。\n\n对于某些比较复杂的组件，这种外部组件的使用方式会更加方便。\n\n\n配置#\n\n这个插件接受一个对象参数，类型如下:\n\n\n\n\ndefaultRenderMode#\n\n支持用户配置没有主动声明 pure 或 preview 标识符的内部代码块的默认行为，默认为 preview。\n\n * pure: 渲染为普通代码块\n * preview: 渲染为预览组件\n\n\npreviewMode#\n\npreviewMode 参数用于指定预览组件是否内置，默认为 internal。默认内置模式的展示效果如下：\n\n\n\n你也可以针对单个代码块设置，例如\n\n\n\n\n\n如果使用 iframe 预览模式，还有以下配置：\n\n\niframeOptions.position#\n\n在 iframe 预览模式下时，你可以通过 position 参数来决定预览区 iframe 的位置，是跟随页面滚动(follow\n模式)还是固定在页面中(fixed 模式)，默认为 follow。\n\nfollow 模式效果如下：\n\n\n\nfixed 模式效果如下：\n\n\n\n\niframeOptions.framework#\n\n在 iframe 预览模式下，你可以选择渲染框架，目前支持 react 和 solid。\n\n\niframeOptions.devPort#\n\n在 iframe 预览模式下，你可以配置预览组件的 dev server port。\n\n\niframeOptions.builderConfig#\n\n配置 iframe 的构建配置，例如添加一些全局代码逻辑。\n\n\ndeprecated: isMobile#\n\n从 1.12.0 版本开始，请使用 previewMode 配置预览模式。\n\n\ndeprecated: iframePosition#\n\n从 1.12.0 版本开始，请使用 iframeOptions.position。","routePath":"/zh/plugin/official-plugins/preview","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":26},{"text":"使用","id":"使用","depth":2,"charIndex":32},{"text":"引入插件","id":"引入插件","depth":3,"charIndex":38},{"text":"内部组件","id":"内部组件","depth":3,"charIndex":138},{"text":"外部组件","id":"外部组件","depth":3,"charIndex":448},{"text":"配置","id":"配置","depth":2,"charIndex":644},{"text":"defaultRenderMode","id":"defaultrendermode","depth":3,"charIndex":672},{"text":"previewMode","id":"previewmode","depth":3,"charIndex":789},{"text":"iframeOptions.position","id":"iframeoptionsposition","depth":3,"charIndex":910},{"text":"iframeOptions.framework","id":"iframeoptionsframework","depth":3,"charIndex":1072},{"text":"iframeOptions.devPort","id":"iframeoptionsdevport","depth":3,"charIndex":1145},{"text":"iframeOptions.builderConfig","id":"iframeoptionsbuilderconfig","depth":3,"charIndex":1214},{"text":"deprecated: isMobile","id":"deprecated-ismobile","depth":3,"charIndex":1276},{"text":"deprecated: iframePosition","id":"deprecated-iframeposition","depth":3,"charIndex":1339}],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"@rspress/plugin-shiki","content":"#\n\n集成 Shiki 代码高亮插件。在默认情况下，Rspress 会基于 Prism.js\n来实现语法高亮。不过在某些情况下，你需要实现更多语言的代码高亮，Prism.js 可能不够用，此时你可以接入该插件，使用 Shiki 支持更多的语言。\n\n注意\n\n不过，引入该 Shiki 插件之后，Rspress 的编译性能会有所下降，所以请根据自己的需求来评估是否需要引入该插件。\n\n\n安装#\n\n\n使用#\n\n首先在配置文件中写入以下的配置：\n\n\n\n\n配置#\n\n该插件支持传入一个对象配置，该对象配置的属性如下：\n\n\n\n其中，代码高亮主题使用的是 css-variables，你也可以选择自己喜欢的主题，具体可以参考 Shiki 主题列表文档。\n\n默认支持的语言包括\njs、jsx、ts、tsx、json、css、scss、less、xml、diff、yaml、md、mdx、bash，如果你想支持更多的语言，可以在配置文件中传\n入 langs 属性，该属性是一个数组，数组中的每一项都是一个语言的 id，具体可以参考 Shiki 支持的语言列表。\n\n\nTransformer 概念和使用#\n\nTransformer 是本插件中的一个概念，它的作用是对代码块的特定语法进行转换，比如你可以使用该功能来实现代码块的 diff 高亮效果。\n\n\n内置 Transformer 介绍#\n\n本插件中内置了一些 Transformer，包括：\n\n * createTransformerDiff：实现代码块的 diff 高亮效果。\n * createTransformerLineNumber：实现代码块的行号显示。\n * createTransformerErrorLevel：实现代码块对应行的错误等级显示，包括 error 和 warning。\n * createTransformerHighlight：实现代码块的行高亮显示。\n * createTransformerFocus： 实现代码块的行聚焦显示。\n\n你可以通过配置 transformers 属性来启用这些 Transformer，比如：\n\n\n\n接着我们来介绍一下如何使用这些 Transformer 对应的语法。\n\ndiff 高亮#\n\n在 markdown 的代码块中使用 diff 语法，比如：\n\n\n\n这样会自动对相应行的代码应用 diff 高亮效果。\n\n行号显示#\n\n在 markdown 的代码块中使用 hl 语法，比如：\n\n\n\n这样会自动对相应行的代码显示行号。\n\n错误等级显示#\n\n在 markdown 的代码块中使用 error 或 warning 语法，比如：\n\n\n\n这样会自动对相应行的代码显示错误等级。\n\n行聚焦显示#\n\n在 markdown 的代码块中使用 focus 语法，比如：\n\n\n\n这样会自动对相应行的代码显示聚焦效果。","routePath":"/zh/plugin/official-plugins/shiki","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":190},{"text":"使用","id":"使用","depth":2,"charIndex":196},{"text":"配置","id":"配置","depth":2,"charIndex":222},{"text":"Transformer 概念和使用","id":"transformer-概念和使用","depth":2,"charIndex":473},{"text":"内置 Transformer 介绍","id":"内置-transformer-介绍","depth":3,"charIndex":566},{"text":"diff 高亮","id":"diff-高亮","depth":4,"charIndex":934},{"text":"行号显示","id":"行号显示","depth":4,"charIndex":1005},{"text":"错误等级显示","id":"错误等级显示","depth":4,"charIndex":1063},{"text":"行聚焦显示","id":"行聚焦显示","depth":4,"charIndex":1138}],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"@rspress/plugin-typedoc","content":"#\n\n集成 TypeDoc 的 Rspress 插件，用于自动生成 TS 模块的 API 文档。\n\n\n安装#\n\n\n使用#\n\n\n\n\n\n\n\n当你启动项目后，插件会在你的文档根目录下自动生成 api 目录，目录结构如下：\n\n\n\n也就是说，插件内部会调用 TypeDoc 帮你自动生成模块的 API 文档，包含模块列表、Interface 详情、函数详情(入参、返回值、描述信息)\n等信息，同时也会生成 documentation.json 文件，用于后续的侧边栏渲染。\n\n注意，每次启动项目时都会根据最新的模块内容重新生成文档。因此，我们建议将 api 目录加入 .gitignore 中，如果你通过下面的 outDir\n参数自定义了输出目录，也应该将其加入 .gitignore 中。\n\n同时，我们也不建议在 api 目录下修改或新增文档，因为随着模块内容的变化，这些文档在每次项目启动时会被覆盖。\n\n\n参数说明#\n\n\nentryPoints#\n\n * 类型：string[]\n * 默认值：[]\n\n指定需要生成文档的 TS 模块路径，你需要传入模块的绝对路径。\n\n\noutDir#\n\n * 类型：string\n * 默认值：api\n\n自定义文档输出目录，你需要传入一个相对路径，比如 api/custom。","routePath":"/zh/plugin/official-plugins/typedoc","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":50},{"text":"使用","id":"使用","depth":2,"charIndex":56},{"text":"参数说明","id":"参数说明","depth":2,"charIndex":399},{"text":"entryPoints","id":"entrypoints","depth":3,"charIndex":407},{"text":"outDir","id":"outdir","depth":3,"charIndex":481}],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"介绍","content":"#\n\n插件机制是 Rspress 至关重要的部分，它可以让你在搭建站点的过程中，方便地扩展框架的功能。那么，你可以通过插件扩展哪些功能呢？我们先来看看 Rspress\n的整体架构。\n\nRspress 的整体架构如下图所示：\n\n\n\n框架整体分为Node 端和浏览器运行时两部分。通过插件机制，你可以轻松地扩展这两部分的功能。具体来说，你可以扩展如下的能力:\n\n * Markdown/MDX 编译功能。你可以通过添加 remark/rehype 插件，扩展 Markdown/MDX 的语法和功能。\n * 添加自定义页面。在框架约定式路由的基础，你也可以通过插件，添加新路由，比如添加一个 /blog 路由，用于展示博客列表，内容由你自己定义。\n * 定制构建工具的行为。在框架插件中，你可以自定义底层构建工具 Rspack 的配置，如 define、alias，也可以添加自定义 Rspack 插件。\n * 扩展页面元数据。针对每个页面，框架内部会计算出一些元数据，如 title、description\n   等等，你可以通过插件，扩展这些元数据的计算逻辑，并在运行时通过 usePageData hook 访问到。\n * 在构建流程前后插入一些自定义逻辑。如在构建流程结束后关闭一些事件监听器。\n * 添加全局组件。Rspress 内部使用 React 进行渲染，你可以通过定义全局 React 组件来灵活地扩展页面运行时的功能，比如添加全局的\n   BackToTop(返回顶部) 组件、添加全局副作用逻辑。","routePath":"/zh/plugin/system/introduction","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"插件 API","content":"#\n\n上一节我们介绍了插件的基本结构，本节我们来介绍插件的 API，帮助你更细致地了解插件功能。\n\n提示\n\n为了获得更好的类型提示，你可以在项目中安装 @rspress/shared，然后通过 `` 来引入 RspressPlugin 类型。\n\n\nglobalStyles#\n\n * 类型：string\n\n用于添加全局样式，传入一个样式文件的绝对路径，使用方式如下：\n\n\n\n比如你想修改主题色，可以通过添加全局样式来实现：\n\n\n\n\nglobalUIComponents#\n\n * 类型：(string | [string, object])[]\n\n用于添加全局组件，传入一个数组，数组中的每一项都是一个组件的绝对路径，使用方式如下：\n\n\n\nglobalUIComponents 的每一项可以是一个字符串，代表组件的文件路径；也可以是一个数组，第一项为组件的文件路径，第二项为组件的 props\n对象，比如：\n\n\n\n当你注册了全局组件之后，框架会自动将这些 React 组件在主题中进行渲染，而不用你手动引入。\n\n通过全局组件，你可以完成诸多自定义的功能，比如:\n\n\n\n这样，在主题页面中会渲染组件的内容，比如添加回到顶部按钮。\n\n同时，你也可以通过全局组件来注册全局副作用。比如：\n\n\n\n这样，在主题页面中会执行组件的副作用。比如以下的一些需要副作用的场景:\n\n * 针对某些页面路由进行重定向操作。\n\n * 对页面的 img 标签进行事件监听，实现图片放大功能。\n\n * 路由变化时，上报不同页面的 PV 数据。\n\n * ......\n\n\nbuilderConfig#\n\n * 类型：RsbuildConfig\n\nRspress 底层基于 Rsbuild 来进行文档构建。通过 builderConfig 可以对 Rsbuild 进行配置，具体的配置项可以参考\nRsbuild - 配置。\n\n> 当然，如果你想要直接配置 Rspack，也可以通过 builderConfig.tools.rspack 进行配置。\n\n\n\n\nconfig#\n\n * 类型：(config: DocConfig, utils: ConfigUtils, isProd: boolean) => DocConfig |\n   Promise\n\n其中，ConfigUtils 的类型定义如下：\n\n\n\n用于修改 Rspress 本身的配置，比如你想要修改文档的标题，可以通过 config 来实现：\n\n\n\n如果涉及到添加和删除插件，需要通过 addPlugin 和 removePlugin 来实现：\n\n\n\n\nbeforeBuild/afterBuild#\n\n * 类型：(config: DocConfig, isProd: boolean) => void | Promise\n\n用于在文档构建之前/之后执行一些操作，第一个参数是文档的配置，第二个参数是当前是否是生产环境。使用方式如下：\n\n\n\n提醒\n\n在 beforeBuild 钩子执行时，已经经过了所有插件的 config 插件处理，因此 config 参数已经代表了最终的文档配置。\n\n\nmarkdown#\n\n * 类型：{ remarkPlugins?: Plugin[]; rehypePlugins?: Plugin[]; globalComponents?:\n   string[] }\n\n用于扩展 Markdown/MDX 的编译能力，如果你想要添加自定义的 remark/rehype 插件以及 MDX 里的全局组件，可以通过 markdown\n配置来实现：\n\n\n\n\nextendPageData#\n\n * 类型：(pageData: PageData) => void | Promise\n\n用于扩展页面数据，比如你想要在页面数据中添加一些自定义的属性，可以通过 extendPageData 来实现：\n\n\n\n在扩展页面数据之后，你可以在主题中通过 usePageData 这个 hook 来访问页面数据。\n\n\n\n\naddPages#\n\n * 类型：(config: UserConfig) => AdditionalPage[] | Promise\n\n其中，config 为 rspress.config.ts 配置文件中导出的 doc 属性值，AdditionalPage 的类型定义如下：\n\n\n\n主要用来添加额外的页面，你可以在 addPages 函数中返回一个数组，数组中的每一项都是一个页面的配置，你可以通过 routePath 来指定页面的路由，通过\nfilepath 或者 content 来指定页面的内容。比如：\n\n\n\naddPages 接受两个参数，config 为当前文档站的配置，isProd 表示是否为生产环境。\n\n\nrouteGenerated#\n\n * 类型：(routeMeta: RouteMeta[]) => void | Promise\n\n这这个钩子中，你可以拿到所有的路由信息，每一项路由信息的结构如下:\n\n\n\n例子:\n\n\n\n\naddRuntimeModules#\n\n * 类型：(config: UserConfig, isProd: boolean) => Record | Promise>;\n\n用于添加额外的运行时模块，比如你想要在文档中使用到某些编译时的信息，可以通过 addRuntimeModules 来实现：\n\n\n\n这样你就可以在运行时组件中使用 virtual-xxx 模块了：\n\n\n\n提醒\n\n该 hook 在 routeGenerated 之后执行。","routePath":"/zh/plugin/system/plugin-api","lang":"zh","toc":[{"text":"globalStyles","id":"globalstyles","depth":3,"charIndex":123},{"text":"globalUIComponents","id":"globaluicomponents","depth":3,"charIndex":215},{"text":"builderConfig","id":"builderconfig","depth":3,"charIndex":670},{"text":"config","id":"config","depth":3,"charIndex":861},{"text":"beforeBuild/afterBuild","id":"beforebuildafterbuild","depth":3,"charIndex":1091},{"text":"markdown","id":"markdown","depth":3,"charIndex":1311},{"text":"extendPageData","id":"extendpagedata","depth":3,"charIndex":1507},{"text":"addPages","id":"addpages","depth":3,"charIndex":1682},{"text":"routeGenerated","id":"routegenerated","depth":3,"charIndex":1995},{"text":"addRuntimeModules","id":"addruntimemodules","depth":3,"charIndex":2107}],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"编写一个插件","content":"#\n\n我们以注入一个全局组件为例，来看看如何定义和使用插件。\n\n提示\n\n为了获得更好的类型提示，你可以在项目中安装 @rspress/shared，然后通过 `` 来引入 RspressPlugin 类型。\n\n\n1. 定义插件#\n\n\n\n\n\n插件一般为一个函数，接收一些插件参数(可选)，返回一个对象，对象中包含插件的名称以及其它配置。在上面的例子中，我们定义了一个插件，它的名称为\nplugin-example，它会在构建阶段定义一个全局变量 process.env.SLUG，并且在文档中注入一个全局组件 Example.tsx。\n\n\n2. 使用插件#\n\n在 rspress.config.ts 中通过 plugins 注册插件:\n\n\n\n这样，Example 组件会自动在页面中渲染，并且我们可以在 Example 组件中访问到 process.env.SLUG。","routePath":"/zh/plugin/system/write-a-plugin","lang":"zh","toc":[{"text":"1. 定义插件","id":"1-定义插件","depth":3,"charIndex":105},{"text":"2. 使用插件","id":"2-使用插件","depth":3,"charIndex":268}],"domain":"","frontmatter":{},"version":""}]